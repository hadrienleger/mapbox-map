<div id="location-map-container" style="width:100%;height:230px;border-radius:16px;overflow:hidden;"></div>

<link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />
<script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
<script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v4.7.2/mapbox-gl-geocoder.min.js"></script>
<link
  rel="stylesheet"
  href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v4.7.2/mapbox-gl-geocoder.css"
/>
<script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>

<script>
  // 1) MAP GLOBALE POUR LA SHEET
  window.locationMap = null;

  // ====== COLLECTIVITÃ‰S (MINI-CARTE) ======

  // FC complet des collectivitÃ©s actuellement affichÃ©es
  window.locationMap_collectivitesData = {
    type: "FeatureCollection",
    features: []
  };

  // Set des codes INSEE des collectivitÃ©s affichÃ©es
  window.locationMap_collectiviteCodes = new Set();

  // DerniÃ¨re emprise utilisÃ©e pour fitBounds
  window.locationMap_lastCollectivitesBBox = null;
  window.locationMap_lastCollectivitesPad  = 60;

  function initLocationMap() {
    if (window.locationMap) return;

    const container = document.getElementById('location-map-container');
    if (!container || !window.mapboxgl) {
      setTimeout(initLocationMap, 300);
      return;
    }

    mapboxgl.accessToken = 'pk.eyJ1IjoiaGFkcmllbmxlZ2VyIiwiYSI6ImNtYXBjbDlzYTBncGoyaXNhN3dpajI3b3MifQ.TatwRPDuazMQH2DfSkxv2w';

    window.locationMap = new mapboxgl.Map({
      container: 'location-map-container',
      style: 'mapbox://styles/mapbox/light-v11',
      center: [2.35, 48.86],
      zoom: 10
    });

    console.log('âœ… Mini-carte initialisÃ©e');
  }

  // Lance l'init quand la sheet est montÃ©e
  document.addEventListener('DOMContentLoaded', initLocationMap);
  setTimeout(initLocationMap, 500);

  // 2) FONCTIONS EXPOSÃ‰ES Ã€ BUBBLE

  // a) Afficher les polygones de collectivitÃ©s (mode "Par zones")
  window.locationMap_showCollectivitePolygons = function (fc) {
    console.log('ðŸ“ locationMap_showCollectivitePolygons appelÃ©e avec', fc);
    
    const map = window.locationMap;
    if (!map) {
      console.warn("ðŸ›‘ locationMap non initialisÃ©e pour showCollectivitePolygons");
      return;
    }

    // VÃ©rifier que la carte est chargÃ©e
    if (!map.loaded()) {
      console.log("â³ Carte pas encore chargÃ©e, attente...");
      map.once('load', () => {
        window.locationMap_showCollectivitePolygons(fc);
      });
      return;
    }

    if (!fc || !fc.features || fc.features.length === 0) {
      console.log("ðŸ§¹ Aucune collectivitÃ© Ã  afficher, nettoyage");
      // Rien Ã  afficher â†’ on nettoie Ã©ventuellement
      if (map.getSource("loc-collectivites")) {
        ["loc-collectivites-fill", "loc-collectivites-outline"].forEach((id) => {
          if (map.getLayer(id)) map.removeLayer(id);
        });
        map.removeSource("loc-collectivites");
      }
      window.locationMap_collectivitesData = {
        type: "FeatureCollection",
        features: []
      };
      window.locationMap_collectiviteCodes = new Set();
      window.locationMap_lastCollectivitesBBox = null;
      return;
    }

    // 1) Sauvegarder les donnÃ©es et les codes INSEE
    window.locationMap_collectivitesData = fc;
    window.locationMap_collectiviteCodes = new Set(
      fc.features.map((f) => f.properties.code_insee)
    );
    
    console.log("ðŸ’¾ Sauvegarde de", fc.features.length, "collectivitÃ©s");

    // 2) Source + layers (fill + outline)
    if (map.getSource("loc-collectivites")) {
      map.getSource("loc-collectivites").setData(fc);
      console.log("ðŸ”„ Source mise Ã  jour");
    } else {
      map.addSource("loc-collectivites", {
        type: "geojson",
        data: fc
      });
      map.addLayer({
        id: "loc-collectivites-fill",
        type: "fill",
        source: "loc-collectivites",
        paint: {
          "fill-color": "#8A2BE2",
          "fill-opacity": 0.25
        }
      });
      map.addLayer({
        id: "loc-collectivites-outline",
        type: "line",
        source: "loc-collectivites",
        paint: {
          "line-color": "#8A2BE2",
          "line-width": 2
        }
      });
      console.log("âž• Source et layers crÃ©Ã©s");
    }

    // 3) Calculer la bbox de TOUTES les collectivitÃ©s et fitter la carte
    try {
      const bbox = turf.bbox(fc); // [minX, minY, maxX, maxY]
      window.locationMap_lastCollectivitesBBox = bbox;
      window.locationMap_lastCollectivitesPad = 60;

      console.log("ðŸ“¦ BBox calculÃ©e:", bbox);
      console.log("ðŸ” map.loaded() =", map.loaded());
      console.log("ðŸ” map.isStyleLoaded() =", map.isStyleLoaded());

      // SOLUTION ROBUSTE: Toujours exÃ©cuter avec un micro-dÃ©lai
      // pour laisser le temps Ã  Mapbox de se synchroniser
      const executeFitBounds = () => {
        try {
          map.fitBounds(bbox, {
            padding: 60,
            duration: 600
          });
          console.log("âœ… fitBounds appliquÃ© avec succÃ¨s");
        } catch (e) {
          console.error("âŒ Erreur fitBounds:", e);
          // RÃ©essayer aprÃ¨s un dÃ©lai en cas d'erreur
          setTimeout(() => {
            try {
              map.fitBounds(bbox, {
                padding: 60,
                duration: 600
              });
              console.log("âœ… fitBounds appliquÃ© (2e tentative)");
            } catch (e2) {
              console.error("âŒ Ã‰chec dÃ©finitif fitBounds:", e2);
            }
          }, 300);
        }
      };

      // Toujours utiliser un dÃ©lai court pour la fiabilitÃ©
      setTimeout(executeFitBounds, 100);
    } catch (error) {
      console.error("âŒ Erreur lors du calcul de bbox:", error);
    }
  };

  // b) Supprimer UNE collectivitÃ© par son code INSEE et refitBounds
  window.locationMap_removeCollectivite = function (code) {
    console.log('ðŸ—‘ï¸ Suppression collectivitÃ©:', code);
    
    const map = window.locationMap;
    if (!map || !map.getSource("loc-collectivites")) return;
    if (!window.locationMap_collectiviteCodes.has(code)) return;

    window.locationMap_collectiviteCodes.delete(code);

    const remainingFeatures = Array.from(
      window.locationMap_collectiviteCodes
    )
      .map((c) =>
        window.locationMap_collectivitesData.features.find(
          (f) => f.properties.code_insee === c
        )
      )
      .filter(Boolean);

    const remaining = {
      type: "FeatureCollection",
      features: remainingFeatures
    };

    window.locationMap_collectivitesData = remaining;
    map.getSource("loc-collectivites").setData(remaining);

    if (remaining.features.length) {
      try {
        const bbox = turf.bbox(remaining);
        window.locationMap_lastCollectivitesBBox = bbox;
        
        // Utiliser le mÃªme systÃ¨me de dÃ©lai
        setTimeout(() => {
          try {
            map.fitBounds(bbox, {
              padding: window.locationMap_lastCollectivitesPad || 60,
              duration: 600
            });
            console.log("âœ… Carte ajustÃ©e aprÃ¨s suppression");
          } catch (e) {
            console.error("âŒ Erreur fitBounds aprÃ¨s suppression:", e);
          }
        }, 100);
      } catch (error) {
        console.error("âŒ Erreur calcul bbox aprÃ¨s suppression:", error);
      }
    } else {
      // plus de collectivitÃ©s : on nettoie
      ["loc-collectivites-fill", "loc-collectivites-outline"].forEach((id) => {
        if (map.getLayer(id)) map.removeLayer(id);
      });
      map.removeSource("loc-collectivites");
      window.locationMap_lastCollectivitesBBox = null;
      console.log("ðŸ§¹ DerniÃ¨re collectivitÃ© supprimÃ©e, nettoyage complet");
    }
  };

  // c) Afficher la zone de rayon (mode "Par rayon")
  window.locationMap_showRadius = function (centerLng, centerLat, radiusKm) {
    const map = window.locationMap;
    if (!map || !centerLng || !centerLat || !radiusKm) return;

    // VÃ©rifier que la carte est chargÃ©e
    if (!map.loaded()) {
      map.once('load', () => {
        window.locationMap_showRadius(centerLng, centerLat, radiusKm);
      });
      return;
    }

    const circle = turf.circle([centerLng, centerLat], radiusKm, {
      steps: 128,
      units: 'kilometers'
    });

    if (map.getLayer('loc-radius-fill')) map.removeLayer('loc-radius-fill');
    if (map.getLayer('loc-radius-outline')) map.removeLayer('loc-radius-outline');
    if (map.getSource('loc-radius')) map.removeSource('loc-radius');

    map.addSource('loc-radius', {
      type: 'geojson',
      data: circle
    });

    map.addLayer({
      id: 'loc-radius-fill',
      type: 'fill',
      source: 'loc-radius',
      paint: {
        'fill-color': '#9B51E0',
        'fill-opacity': 0.18
      }
    });

    map.addLayer({
      id: 'loc-radius-outline',
      type: 'line',
      source: 'loc-radius',
      paint: {
        'line-color': '#9B51E0',
        'line-width': 2,
        'line-opacity': 0.9
      }
    });

    map.fitBounds(turf.bbox(circle), { padding: 20, duration: 600 });
    console.log("âœ… Rayon affichÃ© et carte ajustÃ©e");
  };

  // d) Initialiser le geocoder (mode Par rayon)
  window.locationMap_initGeocoder = function () {
    const map = window.locationMap;
    if (!map || !window.MapboxGeocoder) return;
    
    const container = document.getElementById('radius-search-container');
    if (!container) return;
    
    // Ã©viter plusieurs geocoders
    if (container.dataset.geocoderInit === '1') return;
    container.dataset.geocoderInit = '1';
    
    const geocoder = new MapboxGeocoder({
        accessToken: mapboxgl.accessToken,
        mapboxgl: mapboxgl,
        marker: false,
        placeholder: 'Adresse ou lieuâ€¦',
        language: 'fr'
    });
    
    container.innerHTML = '';
    container.appendChild(geocoder.onAdd(map));
    
    // Fonction pour rÃ©afficher les boutons
    const showButtons = () => {
        const buttonGroup = document.getElementById('fg_group_rayon');
        if (buttonGroup) {
            buttonGroup.style.visibility = 'visible';
            buttonGroup.style.pointerEvents = 'auto';
            console.log('ðŸ‘ï¸ Boutons rÃ©affichÃ©s');
        }
    };
    
    // Fonction pour cacher les boutons
    const hideButtons = () => {
        const buttonGroup = document.getElementById('fg_group_rayon');
        if (buttonGroup) {
            buttonGroup.style.visibility = 'hidden';
            buttonGroup.style.pointerEvents = 'none';
            console.log('ðŸ™ˆ Boutons cachÃ©s');
        }
    };
    
    // === FORCER LE Z-INDEX DES SUGGESTIONS DÃˆS LEUR APPARITION ===
    const observer = new MutationObserver(() => {
        const suggestions = container.querySelector('.suggestions');
        
        if (suggestions) {
            suggestions.style.position = 'absolute';
            suggestions.style.zIndex = '999999';
            suggestions.style.visibility = 'visible';
            suggestions.style.display = 'block';
            suggestions.style.pointerEvents = 'auto';
            
            hideButtons();
        } else {
            showButtons();
        }
    });
    
    observer.observe(container, {
        childList: true,
        subtree: true
    });
    
    // === Ã‰VÃ‰NEMENTS DU GEOCODER POUR RÃ‰AFFICHER LES BOUTONS ===
    
    // Quand une suggestion est sÃ©lectionnÃ©e
    geocoder.on('result', (e) => {
        const [lng, lat] = e.result.center;
        window.locationMap_lastCenter = { lng, lat };
        
        if (typeof bubble_fn_radiusCenter === 'function') {
            bubble_fn_radiusCenter({ output1: lng, output2: lat });
        }
        
        map.flyTo({ center: [lng, lat], zoom: 12 });
        
        // IMPORTANT: RÃ©afficher les boutons aprÃ¨s sÃ©lection
        setTimeout(showButtons, 100);
    });
    
    // Quand l'utilisateur efface le texte (clic sur X ou backspace)
    geocoder.on('clear', () => {
        console.log('ðŸ§¹ Recherche effacÃ©e');
        showButtons();
    });
    
    // Fallback: RÃ©afficher les boutons si l'input perd le focus
    const input = container.querySelector('.mapboxgl-ctrl-geocoder--input');
    if (input) {
        input.addEventListener('blur', () => {
            setTimeout(() => {
                // VÃ©rifier qu'il n'y a vraiment plus de suggestions
                const suggestions = container.querySelector('.suggestions');
                if (!suggestions || suggestions.children.length === 0) {
                    showButtons();
                }
            }, 200);
        });
    }
  };
</script>