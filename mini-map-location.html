<div id="location-map-container" style="width:100%;height:230px;border-radius:16px;overflow:hidden;"></div>

<link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />
<script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
<script src="https://api.mapbox.com/search-js/v1.0.0/web.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>

<script>
  // 1) MAP GLOBALE POUR LA SHEET
  window.locationMap = null;

  // ====== COLLECTIVIT√âS (MINI-CARTE) ======

  // FC complet des collectivit√©s actuellement affich√©es
  window.locationMap_collectivitesData = {
    type: "FeatureCollection",
    features: []
  };

  // Set des codes INSEE des collectivit√©s affich√©es
  window.locationMap_collectiviteCodes = new Set();

  // Derni√®re emprise utilis√©e pour fitBounds
  window.locationMap_lastCollectivitesBBox = null;
  window.locationMap_lastCollectivitesPad  = 60;

  // ====== RAYON (MODE PAR RAYON) ======
  
  // Variables globales pour le mode rayon
  window.locationMap_radiusCenter = null;   // {lon, lat}
  window.locationMap_radiusKm     = 5;      // distance en km par d√©faut
  window.locationMap_radiusMarker = null;   // marqueur Mapbox
  window.locationMap_radiusData   = { type: 'FeatureCollection', features: [] };

  function initLocationMap() {
    if (window.locationMap) return;

    const container = document.getElementById('location-map-container');
    if (!container || !window.mapboxgl) {
      setTimeout(initLocationMap, 300);
      return;
    }

    mapboxgl.accessToken = 'pk.eyJ1IjoiaGFkcmllbmxlZ2VyIiwiYSI6ImNtYXBjbDlzYTBncGoyaXNhN3dpajI3b3MifQ.TatwRPDuazMQH2DfSkxv2w';

    window.locationMap = new mapboxgl.Map({
      container: 'location-map-container',
      style: 'mapbox://styles/mapbox/light-v11',
      center: [2.35, 48.86],
      zoom: 10
    });

    console.log('‚úÖ Mini-carte initialis√©e');
  }

  // Lance l'init quand la sheet est mont√©e
  document.addEventListener('DOMContentLoaded', initLocationMap);
  setTimeout(initLocationMap, 500);

  // 2) FONCTIONS EXPOS√âES √Ä BUBBLE

  // a) Afficher les polygones de collectivit√©s (mode "Par zones")
  window.locationMap_showCollectivitePolygons = function (fc) {
    console.log('üìç locationMap_showCollectivitePolygons appel√©e avec', fc);
    
    const map = window.locationMap;
    if (!map) {
      console.warn("üõë locationMap non initialis√©e pour showCollectivitePolygons");
      return;
    }

    // V√©rifier que la carte est charg√©e
    if (!map.loaded()) {
      console.log("‚è≥ Carte pas encore charg√©e, attente...");
      map.once('load', () => {
        window.locationMap_showCollectivitePolygons(fc);
      });
      return;
    }

    if (!fc || !fc.features || fc.features.length === 0) {
      console.log("üßπ Aucune collectivit√© √† afficher, nettoyage");
      // Rien √† afficher ‚Üí on nettoie √©ventuellement
      if (map.getSource("loc-collectivites")) {
        ["loc-collectivites-fill", "loc-collectivites-outline"].forEach((id) => {
          if (map.getLayer(id)) map.removeLayer(id);
        });
        map.removeSource("loc-collectivites");
      }
      window.locationMap_collectivitesData = {
        type: "FeatureCollection",
        features: []
      };
      window.locationMap_collectiviteCodes = new Set();
      window.locationMap_lastCollectivitesBBox = null;
      return;
    }

    // 1) Sauvegarder les donn√©es et les codes INSEE
    window.locationMap_collectivitesData = fc;
    window.locationMap_collectiviteCodes = new Set(
      fc.features.map((f) => f.properties.code_insee)
    );
    
    console.log("üíæ Sauvegarde de", fc.features.length, "collectivit√©s");

    // 2) Source + layers (fill + outline)
    if (map.getSource("loc-collectivites")) {
      map.getSource("loc-collectivites").setData(fc);
      console.log("üîÑ Source mise √† jour");
    } else {
      map.addSource("loc-collectivites", {
        type: "geojson",
        data: fc
      });
      map.addLayer({
        id: "loc-collectivites-fill",
        type: "fill",
        source: "loc-collectivites",
        paint: {
          "fill-color": "#8A2BE2",
          "fill-opacity": 0.25
        }
      });
      map.addLayer({
        id: "loc-collectivites-outline",
        type: "line",
        source: "loc-collectivites",
        paint: {
          "line-color": "#8A2BE2",
          "line-width": 2
        }
      });
      console.log("‚ûï Source et layers cr√©√©s");
    }

    // 3) Calculer la bbox de TOUTES les collectivit√©s et fitter la carte
    try {
      const bbox = turf.bbox(fc); // [minX, minY, maxX, maxY]
      window.locationMap_lastCollectivitesBBox = bbox;
      window.locationMap_lastCollectivitesPad = 60;

      console.log("üì¶ BBox calcul√©e:", bbox);
      console.log("üîç map.loaded() =", map.loaded());
      console.log("üîç map.isStyleLoaded() =", map.isStyleLoaded());

      // SOLUTION ROBUSTE: Toujours ex√©cuter avec un micro-d√©lai
      // pour laisser le temps √† Mapbox de se synchroniser
      const executeFitBounds = () => {
        try {
          map.fitBounds(bbox, {
            padding: 60,
            duration: 600
          });
          console.log("‚úÖ fitBounds appliqu√© avec succ√®s");
        } catch (e) {
          console.error("‚ùå Erreur fitBounds:", e);
          // R√©essayer apr√®s un d√©lai en cas d'erreur
          setTimeout(() => {
            try {
              map.fitBounds(bbox, {
                padding: 60,
                duration: 600
              });
              console.log("‚úÖ fitBounds appliqu√© (2e tentative)");
            } catch (e2) {
              console.error("‚ùå √âchec d√©finitif fitBounds:", e2);
            }
          }, 300);
        }
      };

      // Toujours utiliser un d√©lai court pour la fiabilit√©
      setTimeout(executeFitBounds, 100);
    } catch (error) {
      console.error("‚ùå Erreur lors du calcul de bbox:", error);
    }
  };

  // ====== FONCTIONS POUR LE RAYON (MODE PAR RAYON) ======
  
  // Dessiner le cercle de rayon (fonction interne)
  function drawLocationRadius() {
    console.log('üóëÔ∏è Suppression collectivit√©:', code);
    
    const map = window.locationMap;
    if (!map || !map.getSource("loc-collectivites")) return;
    if (!window.locationMap_collectiviteCodes.has(code)) return;

    window.locationMap_collectiviteCodes.delete(code);

    const remainingFeatures = Array.from(
      window.locationMap_collectiviteCodes
    )
      .map((c) =>
        window.locationMap_collectivitesData.features.find(
          (f) => f.properties.code_insee === c
        )
      )
      .filter(Boolean);

    const remaining = {
      type: "FeatureCollection",
      features: remainingFeatures
    };

    window.locationMap_collectivitesData = remaining;
    map.getSource("loc-collectivites").setData(remaining);

    if (remaining.features.length) {
      try {
        const bbox = turf.bbox(remaining);
        window.locationMap_lastCollectivitesBBox = bbox;
        
        // Utiliser le m√™me syst√®me de d√©lai
        setTimeout(() => {
          try {
            map.fitBounds(bbox, {
              padding: window.locationMap_lastCollectivitesPad || 60,
              duration: 600
            });
            console.log("‚úÖ Carte ajust√©e apr√®s suppression");
          } catch (e) {
            console.error("‚ùå Erreur fitBounds apr√®s suppression:", e);
          }
        }, 100);
      } catch (error) {
        console.error("‚ùå Erreur calcul bbox apr√®s suppression:", error);
      }
    } else {
      // plus de collectivit√©s : on nettoie
      ["loc-collectivites-fill", "loc-collectivites-outline"].forEach((id) => {
        if (map.getLayer(id)) map.removeLayer(id);
      });
      map.removeSource("loc-collectivites");
      window.locationMap_lastCollectivitesBBox = null;
      console.log("üßπ Derni√®re collectivit√© supprim√©e, nettoyage complet");
    }
  };

  // b) Supprimer UNE collectivit√© par son code INSEE et refitBounds
    console.log("‚û°Ô∏è drawLocationRadius appel√©e:", { 
      center: window.locationMap_radiusCenter, 
      radiusKm: window.locationMap_radiusKm 
    });

    const map = window.locationMap;
    if (!map || !map.loaded()) {
      console.warn("üõë Carte non charg√©e");
      return;
    }

    if (!window.locationMap_radiusCenter || 
        typeof window.locationMap_radiusCenter.lon !== 'number' || 
        typeof window.locationMap_radiusCenter.lat !== 'number') {
      console.warn("üõë Centre du rayon invalide");
      return;
    }

    if (typeof window.locationMap_radiusKm !== 'number' || window.locationMap_radiusKm <= 0) {
      console.warn("üõë Rayon invalide, utilisation de 5km par d√©faut");
      window.locationMap_radiusKm = 5;
    }

    // G√©n√©rer le GeoJSON du cercle
    let geojson;
    try {
      const circleFeature = turf.circle(
        [window.locationMap_radiusCenter.lon, window.locationMap_radiusCenter.lat], 
        window.locationMap_radiusKm, 
        { steps: 64, units: 'kilometers' }
      );
      geojson = {
        type: 'FeatureCollection',
        features: [circleFeature]
      };
    } catch (error) {
      console.error("üõë Erreur g√©n√©ration cercle:", error);
      return;
    }

    // Sauvegarder dans window.locationMap_radiusData
    window.locationMap_radiusData = geojson;
    console.log("‚úÖ Donn√©es rayon sauvegard√©es:", geojson.features.length, "features");

    // Mettre √† jour ou cr√©er la source et les couches
    if (map.getSource('loc-radius')) {
      map.getSource('loc-radius').setData(geojson);
      console.log("üîÑ Source rayon mise √† jour");
    } else {
      try {
        map.addSource('loc-radius', { type: 'geojson', data: geojson });
        map.addLayer({
          id: 'loc-radius-fill',
          type: 'fill',
          source: 'loc-radius',
          paint: { 
            'fill-color': '#8A2BE2', 
            'fill-opacity': 0.25 
          }
        });
        map.addLayer({
          id: 'loc-radius-outline',
          type: 'line',
          source: 'loc-radius',
          paint: { 
            'line-color': '#8A2BE2', 
            'line-width': 2 
          }
        });
        console.log("‚ûï Source et layers rayon cr√©√©s");
      } catch (error) {
        console.error("üõë Erreur ajout source/layers rayon:", error);
      }
    }

    // Ajuster la carte sur le cercle
    try {
      const bbox = turf.bbox(geojson);
      setTimeout(() => {
        map.fitBounds(bbox, { 
          padding: 40,  // Padding pour voir le cercle entier confortablement
          duration: 600 
        });
        console.log("‚úÖ Carte ajust√©e sur le rayon");
      }, 100);
    } catch (error) {
      console.error("üõë Erreur fitBounds rayon:", error);
    }
  }

  // c3) Expos√© √† Bubble : changer le rayon
  window.locationMap_updateRadius = function(km) {
    console.log("üìç locationMap_updateRadius appel√©e avec:", km);
    
    if (typeof km !== 'number' || isNaN(km) || km <= 0) {
      console.warn("üõë Rayon invalide, utilisation de 5km par d√©faut");
      window.locationMap_radiusKm = 5;
    } else {
      window.locationMap_radiusKm = km;
    }
    
    drawLocationRadius();
  };

  // c4) Expos√© √† Bubble : effacer le rayon
  window.locationMap_clearRadius = function() {
    console.log("üßπ locationMap_clearRadius appel√©e");

    const map = window.locationMap;
    
    // 1. Supprimer le cercle
    if (map && map.getSource('loc-radius')) {
      if (map.getLayer('loc-radius-fill')) {
        map.removeLayer('loc-radius-fill');
        console.log("‚úÖ Layer loc-radius-fill supprim√©");
      }
      if (map.getLayer('loc-radius-outline')) {
        map.removeLayer('loc-radius-outline');
        console.log("‚úÖ Layer loc-radius-outline supprim√©");
      }
      map.removeSource('loc-radius');
      console.log("‚úÖ Source loc-radius supprim√©e");
    }

    // 2. Supprimer le marqueur
    if (window.locationMap_radiusMarker) {
      window.locationMap_radiusMarker.remove();
      window.locationMap_radiusMarker = null;
      console.log("‚úÖ Marqueur supprim√©");
    }

    // 3. R√©initialiser les variables
    window.locationMap_radiusCenter = null;
    window.locationMap_radiusKm = 5;
    window.locationMap_radiusData = { type: 'FeatureCollection', features: [] };
    console.log("‚úÖ Variables rayon r√©initialis√©es");
  };

  // d) Initialiser la SearchBox (mode Par rayon) - VERSION SEARCHBOX API
  window.locationMap_initGeocoder = function () {
    const map = window.locationMap;
    if (!map || !window.mapboxsearch) {
      console.log("‚è≥ En attente de mapboxsearch...");
      setTimeout(window.locationMap_initGeocoder, 300);
      return;
    }
    
    const container = document.getElementById('radius-search-container');
    if (!container) {
      console.log("‚è≥ Conteneur radius-search-container introuvable");
      setTimeout(window.locationMap_initGeocoder, 300);
      return;
    }
    
    // √©viter plusieurs searchbox
    if (container.dataset.searchboxInit === '1') {
      console.log("‚úÖ SearchBox d√©j√† initialis√©e");
      return;
    }
    container.dataset.searchboxInit = '1';
    
    // Cr√©er la SearchBox (API moderne)
    const sb = new mapboxsearch.MapboxSearchBox();
    sb.accessToken = mapboxgl.accessToken;
    sb.options = {
      types: 'address,poi',
      language: 'fr',
      placeholder: 'Adresse ou lieu‚Ä¶'
    };
    sb.mapboxgl = mapboxgl;
    sb.marker = false;
    sb.bindMap(map);
    
    container.innerHTML = '';
    container.appendChild(sb);
    sb.style.width = '100%';
    
    // Fonction pour r√©afficher les boutons
    const showButtons = () => {
        const buttonGroup = document.getElementById('fg_group_rayon');
        if (buttonGroup) {
            buttonGroup.style.visibility = 'visible';
            buttonGroup.style.pointerEvents = 'auto';
            console.log('üëÅÔ∏è Boutons r√©affich√©s');
        }
    };
    
    // Fonction pour cacher les boutons
    const hideButtons = () => {
        const buttonGroup = document.getElementById('fg_group_rayon');
        if (buttonGroup) {
            buttonGroup.style.visibility = 'hidden';
            buttonGroup.style.pointerEvents = 'none';
            console.log('üôà Boutons cach√©s');
        }
    };
    
    // Observer les suggestions pour cacher/afficher les boutons
    const observer = new MutationObserver(() => {
        const suggestions = container.querySelector('.suggestions');
        
        if (suggestions && suggestions.children.length > 0) {
            // Forcer le z-index des suggestions
            suggestions.style.position = 'absolute';
            suggestions.style.zIndex = '999999';
            suggestions.style.visibility = 'visible';
            suggestions.style.display = 'block';
            suggestions.style.pointerEvents = 'auto';
            
            hideButtons();
        } else {
            showButtons();
        }
    });
    
    observer.observe(container, {
        childList: true,
        subtree: true
    });
    
    // === √âV√âNEMENT: S√©lection d'une suggestion ===
    sb.addEventListener('retrieve', (e) => {
        const [lon, lat] = e.detail.features[0].geometry.coordinates;
        
        console.log('üìç Lieu s√©lectionn√©:', lon, lat);
        
        // 1) Sauvegarder le centre pour le cercle
        window.locationMap_radiusCenter = { lon, lat };
        
        // 2) Cr√©er ou d√©placer le marqueur
        if (!window.locationMap_radiusMarker) {
            window.locationMap_radiusMarker = new mapboxgl.Marker({ 
                color: '#8A2BE2' 
            })
            .setLngLat([lon, lat])
            .addTo(map);
            console.log('‚ûï Marqueur cr√©√©');
        } else {
            window.locationMap_radiusMarker.setLngLat([lon, lat]);
            console.log('üîÑ Marqueur d√©plac√©');
        }
        
        // 3) Dessiner le cercle avec le rayon actuel (1km par d√©faut)
        // Le cercle fera automatiquement un fitBounds pour se montrer entier
        if (!window.locationMap_radiusKm || window.locationMap_radiusKm <= 0) {
            window.locationMap_radiusKm = 1; // Rayon par d√©faut: 1km
        }
        drawLocationRadius();
        
        // 4) Pr√©venir Bubble si la fonction existe
        if (typeof bubble_fn_radiusCenter === 'function') {
            bubble_fn_radiusCenter({ output1: lon, output2: lat });
        }
        
        // 5) R√©afficher les boutons apr√®s s√©lection
        setTimeout(showButtons, 50);
    });
    
    // === √âV√âNEMENT: Effacement de la recherche ===
    sb.addEventListener('clear', () => {
        console.log('üßπ Recherche effac√©e');
        
        // Effacer le marqueur et le cercle
        window.locationMap_clearRadius();
        
        showButtons();
    });
    
    // Fallback: R√©afficher les boutons si l'input perd le focus
    const input = container.querySelector('input');
    if (input) {
        input.addEventListener('blur', () => {
            setTimeout(() => {
                const suggestions = container.querySelector('.suggestions');
                if (!suggestions || suggestions.children.length === 0) {
                    showButtons();
                }
            }, 150);
        });
    }
    
    console.log('‚úÖ SearchBox initialis√©e sur radius-search-container');
  };
</script>