<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Carte Mapbox avec sélection des communes et départements</title>
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet">
  <script defer src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
  <script defer src="https://api.mapbox.com/search-js/v1.0.0/web.js"></script>

  <style>
    .my-map-container {
      margin: 0;
      padding: 0;
      font-family: "Inter", sans-serif;
      position: relative;
      width: 100%;
      height: 100%;
    }
    #map {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 100%;
    }
    .legend {
      position: absolute;
      bottom: 20px;
      right: 20px;
      background: rgba(255, 255, 255, 0.9);
      padding: 10px;
      border-radius: 4px;
      font-size: 12px;
    }
    .legend-item {
      display: flex;
      align-items: center;
      margin: 5px 0;
    }
    .legend-color {
      width: 20px;
      height: 20px;
      margin-right: 5px;
    }
    #search-box-container {
      position: absolute;
      top: 16px;
      left: 50%;
      transform: translateX(-50%);
      width: 300px;
      zIndex: 1;
    }
  </style>
</head>
<body>
  <div class="my-map-container">
    <div id="map"></div>
    <div id="search-box-container"></div>
  </div>

  <script>
    /****************************************************
     * Code principal JavaScript pour la carte Mapbox
     ****************************************************/
    window.map = null; // Variable globale unique
    let currentLayerId = null;
    let currentChoropleth = null; 

    const layerConfigs = {
      iris: {
        source: { type: 'vector', url: 'mapbox://hadrienleger.ak5sb828' },
        sourceLayer: 'iris-ign-petite-etendue-wgs84-7y17me',
        basePaint: {
          'fill-color': ['case', ['boolean', ['feature-state', 'clicked'], false], '#d0a4f7', '#7b2cbf'],
          'fill-opacity': 0.7
        },
        idField: 'CODE_IRIS',
        clickable: true,
        useFeatureStateClicked: true,
        isChoropleth: false,
        labels: { enabled: true, field: 'NOM_IRIS', textSize: 12, color: '#FFF', haloColor: '#000', haloWidth: 1 },
        minzoom: 8,
        maxzoom: 22
      },
      niveauVie: {
        source: { type: 'vector', url: 'mapbox://hadrienleger.filosofi2019' },
        sourceLayer: 'c200_filosofi_2019',
        isChoropleth: true,
        property: 'nv_moyen',
        breaks: [15000, 20000, 25000, 30000, 35000],
        colors: ['#fee5d9', '#fcae91', '#fb6a4a', '#de2d26', '#a50f15', '#67000d'],
        opacity: 0.5,
        clickable: false,
        isChoropleth: true,
        labels: { enabled: false }
      },
      log_soc: {
        source: { type: 'vector', url: 'mapbox://hadrienleger.4m17bbun' },
        sourceLayer: 'carte_iris_logsoc_2021-7slbph',
        isChoropleth: true,
        property: 'part_log_soc',
        breaks: [0.065, 0.2, 0.41, 0.695, 1], // 5 seuils
        colors: ['#eff3ff', '#c6dbef', '#9ecae1', '#6baed6', '#3182bd', '#08519c'], // 6 couleurs
        opacity: 0.8,
        clickable: false,
        isChoropleth: true,
        labels: { enabled: false },
        minzoom: 8,
        maxzoom: 22
      },
  notesInsecurite: {
  source: { type: 'vector', url: 'mapbox://hadrienleger.7ypxua5r' },
  sourceLayer: 'communes_securite-2449ue',
  isChoropleth: true,
  property: 'note_sur_20',
  breaks: [6.81, 9.71, 11.6, 13.11, 14.64, 17.58, 20], // 7 seuils
  colors: ['#10002B', '#240046', '#3C096C', '#5A189A', '#7B2CBF', '#9D4EDD', '#C77DFF', '#E0AAFF'], // 8 couleurs
  opacity: 0.8,
  clickable: false,
  labels: { enabled: true, field: 'note_sur_20', textSize: 12, color: '#333', haloColor: 'rgba(255,255,255,0.8)', haloWidth: 2 },
  minzoom: 8,
  maxzoom: 22
}
    };

    function initializeMap() {
      console.log('Tentative d’initialisation de la carte');
      if (window.map) {
        console.log('Carte déjà initialisée');
        return;
      }
      if (!document.getElementById('map') || typeof mapboxgl === 'undefined') {
        console.log('Mapbox GL JS ou #map non prêt, réessai dans 300ms');
        setTimeout(initializeMap, 300);
        return;
      }

      console.log('Initialisation de la carte...');
      mapboxgl.accessToken = 'pk.eyJ1IjoiaGFkcmllbmxlZ2VyIiwiYSI6ImNsYm1oc3RidzA1NDczdm1xYTJmc3cwcm4ifQ.AguFBTkyTxFnz3VWFBSjrA';
      try {
        window.map = new mapboxgl.Map({
          container: 'map',
          style: 'mapbox://styles/mapbox/streets-v12',
          center: [2.361, 48.852],
          zoom: 10
        });

        window.map.on('load', () => {
          console.log('Carte chargée avec succès');
          Object.keys(layerConfigs).forEach(layerId => {
            if (!window.map.getSource(layerId)) {
              window.map.addSource(layerId, layerConfigs[layerId].source);
            }
          });

          if (typeof mapboxsearch !== 'undefined' && mapboxsearch.MapboxSearchBox) {
            const searchBox = new mapboxsearch.MapboxSearchBox();
            searchBox.accessToken = mapboxgl.accessToken;
            searchBox.options = {
              types: 'address,poi',
              language: 'fr',
              proximity: window.map.getCenter(),
              placeholder: 'Rechercher une adresse ou un lieu'
            };
            searchBox.mapboxgl = mapboxgl;
            searchBox.marker = true;
            searchBox.bindMap(window.map);
            document.getElementById('search-box-container').appendChild(searchBox);

            searchBox.addEventListener('retrieve', (event) => {
              console.log('Résultat de la recherche :', event.detail);
            });
          } else {
            console.warn('Mapbox Search JS non chargé');
          }
        });

        window.map.on('error', (e) => console.error('Erreur Mapbox :', e));
      } catch (error) {
        console.error('Erreur lors de l’initialisation :', error);
      }
    }

   /****************************************************
     * FONCTION hideAllLayers
     * On masque fill, outline et labels
     ****************************************************/
    function hideAllLayers() {  // ****CHANGEMENT****
      if (!window.map) return;
      console.log('=== hideAllLayers called ===');
      Object.keys(layerConfigs).forEach(layerId => {
        // Fill
        if (window.map.getLayer(layerId + '-fill')) {
          window.map.setLayoutProperty(layerId + '-fill', 'visibility', 'none');
        }
        // Outline
        if (window.map.getLayer(layerId + '-outline')) {
          window.map.setLayoutProperty(layerId + '-outline', 'visibility', 'none');
        }
        // Labels
        if (window.map.getLayer(layerId + '-labels')) {
          window.map.setLayoutProperty(layerId + '-labels', 'visibility', 'none');
        }
      });
    }
    window.hideAllLayers = hideAllLayers;

function addLayer(layerId) {
  const config = layerConfigs[layerId];
  if (!config || !window.map) return;

  console.log(`Ajout ou mise à jour de ${layerId} (fill + outline)`);

  // Vérifier si la source existe, sinon l’ajouter
  if (!window.map.getSource(layerId)) {
    console.log(`Source ${layerId} absente, ajout...`);
    try {
      window.map.addSource(layerId, config.source);
      console.log(`Source ${layerId} ajoutée`);
    } catch (error) {
      console.error(`Erreur lors de l’ajout de la source ${layerId}:`, error);
      return;
    }
  }

  let fillPaintObj;
  if (config.isChoropleth) {
    const colorExpr = ["step", ["get", config.property], config.colors[0]];
    config.breaks.forEach((brk, i) => {
      colorExpr.push(brk);
      colorExpr.push(config.colors[i + 1]);
    });
    fillPaintObj = {
      'fill-color': colorExpr,
      'fill-opacity': config.opacity ?? 0.7
    };
    console.log(`Expression choroplèthe pour ${layerId}:`, colorExpr);
  } else {
    fillPaintObj = config.basePaint ? { ...config.basePaint } : {
      'fill-color': '#2C3E50',
      'fill-opacity': 0.8
    };
    if (config.useFeatureStateClicked) {
      fillPaintObj['fill-color'] = [
        'case',
        ['boolean', ['feature-state', 'clicked'], false],
        '#d0a4f7',
        fillPaintObj['fill-color']
      ];
    }
  }

  const fillLayerId = layerId + '-fill';
  if (window.map.getLayer(fillLayerId)) {
    console.log(`Couche ${fillLayerId} déjà présente, mise à jour du style`);
    window.map.setPaintProperty(fillLayerId, 'fill-color', fillPaintObj['fill-color']);
    window.map.setPaintProperty(fillLayerId, 'fill-opacity', fillPaintObj['fill-opacity']);
  } else {
    console.log(`Couche ${fillLayerId} absente, ajout en cours...`);
    try {
      window.map.addLayer({
        id: fillLayerId,
        type: 'fill',
        source: layerId,
        'source-layer': config.sourceLayer,
        minzoom: config.minzoom,
        maxzoom: config.maxzoom,
        paint: fillPaintObj
      }, 'settlement-subdivision-label');
      console.log(`Couche ${fillLayerId} ajoutée`);
    } catch (error) {
      console.error(`Erreur lors de l’ajout de ${fillLayerId}:`, error);
    }
  }

  const outlineLayerId = layerId + '-outline';
  if (window.map.getLayer(outlineLayerId)) {
    console.log(`Couche ${outlineLayerId} déjà présente`);
    // Pas besoin de mise à jour ici, les propriétés sont statiques
  } else {
    console.log(`Couche ${outlineLayerId} absente, ajout en cours...`);
    try {
      window.map.addLayer({
        id: outlineLayerId,
        type: 'line',
        source: layerId,
        'source-layer': config.sourceLayer,
        minzoom: config.minzoom,
        maxzoom: config.maxzoom,
        paint: {
          'line-color': '#FFFFFF',
          'line-width': 1,
          'line-opacity': 0.8,
          'line-blur': 0
        },
        layout: {
          'line-join': 'round',
          'line-cap': 'round'
        }
      }, 'settlement-subdivision-label');
      console.log(`Couche ${outlineLayerId} ajoutée`);
    } catch (error) {
      console.error(`Erreur lors de l’ajout de ${outlineLayerId}:`, error);
    }
  }

  if (config.labels?.enabled) {
    const labelLayerId = `${layerId}-labels`;
    if (window.map.getLayer(labelLayerId)) {
      console.log(`Couche ${labelLayerId} déjà présente`);
    } else {
      console.log(`Couche ${labelLayerId} absente, ajout en cours...`);
      try {
        window.map.addLayer({
          id: labelLayerId,
          type: 'symbol',
          source: layerId,
          'source-layer': config.sourceLayer,
          layout: {
            'text-field': ['get', config.labels.field],
            'text-size': config.labels.textSize || 12,
            'text-anchor': 'center'
          },
          paint: {
            'text-color': config.labels.color || '#000',
            'text-halo-color': config.labels.haloColor || '#fff',
            'text-halo-width': config.labels.haloWidth || 1
          }
        }, 'settlement-subdivision-label');
        console.log(`Couche ${labelLayerId} ajoutée`);
      } catch (error) {
        console.error(`Erreur lors de l’ajout de ${labelLayerId}:`, error);
      }
    }
  }

  if (config.clickable && !window.map.listens('click', fillLayerId)) {
    window.map.on('click', fillLayerId, e => handleLayerClick(e, layerId));
    window.map.on('mouseenter', fillLayerId, () => window.map.getCanvas().style.cursor = 'pointer');
    window.map.on('mouseleave', fillLayerId, () => window.map.getCanvas().style.cursor = '');
  }
}


    let lastClickedFeatureId = null;

    function handleLayerClick(e, layerId) {
      const config = layerConfigs[layerId];
      if (!config || !e.features[0]) return;

      const feature = e.features[0];
      const codeIris = feature.properties[config.idField];
      window.selectGeometry(layerId, codeIris);  // <--- On réutilise la fonction commune
    }

window.updateMapLayers = function(layerId) {
  if (!window.map) return;

  console.log(`Mise à jour de ${layerId}`);

  // Toujours appeler addLayer pour s’assurer que la couche existe
  addLayer(layerId);

  const config = layerConfigs[layerId];
  // Forcer la visibilité
  if (window.map.getLayer(layerId + '-fill')) {
    window.map.setLayoutProperty(layerId + '-fill', 'visibility', 'visible');
    console.log(`${layerId}-fill rendu visible`);
  } else {
    console.error(`${layerId}-fill n’a pas été ajouté`);
  }
  if (window.map.getLayer(layerId + '-outline')) {
    window.map.setLayoutProperty(layerId + '-outline', 'visibility', 'visible');
    console.log(`${layerId}-outline rendu visible`);
  } else {
    console.error(`${layerId}-outline n’a pas été ajouté`);
  }
  if (config?.labels?.enabled && window.map.getLayer(layerId + '-labels')) {
    window.map.setLayoutProperty(layerId + '-labels', 'visibility', 'visible');
    console.log(`${layerId}-labels rendu visible`);
  } else if (config?.labels?.enabled) {
    console.error(`${layerId}-labels n’a pas été ajouté`);
  }

  window.map.triggerRepaint();
  console.log(`Rendu forcé pour ${layerId}`);
};

    // Gestion des couches choropleths
  /****************************************************
     * showChoroplethLayer(layerId)
     * => exclusif : on masque l'ancien + on affiche le nouveau
     ****************************************************/
window.showChoroplethLayer = function(layerId) {
  if (!window.map) {
    console.log(`Carte non initialisée pour ${layerId}, attente...`);
    setTimeout(() => window.showChoroplethLayer(layerId), 300);
    return;
  }

  const config = layerConfigs[layerId];
  if (!config || !config.isChoropleth) {
    console.warn(`${layerId} n’est pas un choroplèthe`);
    return;
  }

  console.log(`[showChoroplethLayer] On veut afficher : ${layerId}`);

  // 1) Masquer tous les autres choroplèthes
  Object.keys(layerConfigs).forEach(other => {
    const c = layerConfigs[other];
    if (c.isChoropleth && other !== layerId) {
      if (window.map.getLayer(other + '-fill')) {
        window.map.setLayoutProperty(other + '-fill', 'visibility', 'none');
        console.log(`${other}-fill masqué`);
      }
      if (window.map.getLayer(other + '-outline')) {
        window.map.setLayoutProperty(other + '-outline', 'visibility', 'none');
        console.log(`${other}-outline masqué`);
      }
      if (c.labels?.enabled && window.map.getLayer(other + '-labels')) {
        window.map.setLayoutProperty(other + '-labels', 'visibility', 'none');
        console.log(`${other}-labels masqué`);
      }
    }
  });

  // 2) Afficher ou réactiver la couche demandée
  window.updateMapLayers(layerId);

  // 3) Mettre à jour le layer courant
  currentChoropleth = layerId;

  // 4) Forcer le rendu
  window.map.triggerRepaint();
  console.log(`Affichage de ${layerId} terminé`);
};


    /****************************************************
     * hideChoropleth()
     * => masque le choropleth actif
     ****************************************************/
    window.hideChoropleth = function() { // ****CHANGEMENT****
      if (!currentChoropleth) return;
      const oldConfig = layerConfigs[currentChoropleth];
      // fill
      if (window.map.getLayer(currentChoropleth + '-fill')) {
        window.map.setLayoutProperty(currentChoropleth + '-fill', 'visibility', 'none');
      }
      // outline
      if (window.map.getLayer(currentChoropleth + '-outline')) {
        window.map.setLayoutProperty(currentChoropleth + '-outline', 'visibility', 'none');
      }
      // labels
      if (oldConfig?.labels?.enabled && window.map.getLayer(currentChoropleth + '-labels')) {
        window.map.setLayoutProperty(currentChoropleth + '-labels', 'visibility', 'none');
      }
      currentChoropleth = null;
    };

window.showLayerAfterResize = function(loadFunctionName, ...args) {
  if (!window.map) {
    console.log("Carte non initialisée, réessai dans 300ms");
    setTimeout(() => window.showLayerAfterResize(loadFunctionName, ...args), 300);
    return;
  }

  console.log(`Début de showLayerAfterResize pour ${loadFunctionName} avec args:`, args);

  window.map.resize();
  setTimeout(() => {
    if (!window.map.isStyleLoaded()) {
      console.log("Style non chargé, attente...");
      window.map.once('render', () => {
        console.log("Carte rendue après resize");
        executeLoadFunction(loadFunctionName, args);
      });
    } else {
      console.log("Style déjà chargé, exécution immédiate");
      executeLoadFunction(loadFunctionName, args);
    }
  }, 200);

  function executeLoadFunction(fnName, fnArgs) {
    if (typeof window[fnName] === 'function') {
      window[fnName](...fnArgs);
      window.map.triggerRepaint();
      console.log(`Exécution de ${fnName} terminée, rendu forcé`);
    } else {
      console.error(`La fonction ${fnName} n’existe pas`);
    }
  }
};


    // On-off d'une couche donnée (hors couches choropleths qui sont gérées par les fonctions showChoropleth et hideChoropleth, vu que les couches chorpoleths sont exclusives)
   window.toggleLayer = function(layerId) { // ****CHANGEMENT****
      const config = layerConfigs[layerId];
      if (!config) return;

      if (config.isChoropleth) {
        console.warn("toggleLayer est conçu pour des layers non-choropleth. Utilise showChoroplethLayer.");
        return;
      }

      addLayer(layerId);

      // On se base sur la visibilité du fill pour décider
      const fillVisibility = window.map.getLayer(layerId + '-fill')
        ? window.map.getLayoutProperty(layerId + '-fill', 'visibility')
        : 'none';
      const newVisibility = (fillVisibility === 'visible') ? 'none' : 'visible';

      // fill
      if (window.map.getLayer(layerId + '-fill')) {
        window.map.setLayoutProperty(layerId + '-fill', 'visibility', newVisibility);
      }
      // outline
      if (window.map.getLayer(layerId + '-outline')) {
        window.map.setLayoutProperty(layerId + '-outline', 'visibility', newVisibility);
      }
      // labels
      if (config.labels?.enabled && window.map.getLayer(layerId + '-labels')) {
        window.map.setLayoutProperty(layerId + '-labels', 'visibility', newVisibility);
      }
    };


    /****************************************************
     * filterIRIS(irisString)
     * => on veut appliquer un filtre sur la couche "iris"
     *    => donc on rend "iris-fill" et "iris-outline"
     *       visibles, on setFilter() sur 'iris-fill' + 'iris-outline' + 'iris-labels'
     ****************************************************/
    window.filterIRIS = function(irisString) { // ****CHANGEMENT****
      if (!window.map) {
        console.log("Carte non initialisée, réessai dans 300ms");
        setTimeout(() => window.filterIRIS(irisString), 300);
        return;
      }

      if (!window.map.loaded()) {
        console.log("Carte non chargée, attente de l’événement 'load'...");
        window.map.once('load', () => window.filterIRIS(irisString));
        return;
      }

      console.log("Application du filtre IRIS avec:", irisString);
      if (lastClickedFeatureId) {
        window.map.removeFeatureState({ source: 'iris', sourceLayer: layerConfigs.iris.sourceLayer });
        lastClickedFeatureId = null;
      }

      let selectedIds = typeof irisString === 'string'
        ? irisString.split(',').map(item => item.trim())
        : irisString;

      hideAllLayers(); // on masque tout

      // Vérifier la source
      if (!window.map.getSource('iris')) {
        console.error("Source 'iris' non trouvée, ajout en cours...");
        window.map.addSource('iris', layerConfigs.iris.source);
      }

      // Ajouter la couche IRIS si besoin
      addLayer('iris');

      // Rendre visible fill, outline, labels
      if (window.map.getLayer('iris-fill')) {
        window.map.setLayoutProperty('iris-fill', 'visibility', 'visible');
      }
      if (window.map.getLayer('iris-outline')) {
        window.map.setLayoutProperty('iris-outline', 'visibility', 'visible');
      }
      if (window.map.getLayer('iris-labels')) {
        window.map.setLayoutProperty('iris-labels', 'visibility', 'visible');
      }

      // Appliquer un setFilter pour restreindre aux IRIS listés
      try {
        const filter = ['match', ['get', 'CODE_IRIS'], selectedIds, true, false];
        if (window.map.getLayer('iris-fill')) {
          window.map.setFilter('iris-fill', filter);
        }
        if (window.map.getLayer('iris-outline')) {
          window.map.setFilter('iris-outline', filter);
        }
        if (window.map.getLayer('iris-labels')) {
          window.map.setFilter('iris-labels', filter);
        }

        // On calcule le bounding box pour l'ensemble
        const features = window.map.querySourceFeatures('iris', {
          sourceLayer: layerConfigs.iris.sourceLayer,
          filter
        });
        if (features.length > 0) {
          const bounds = new mapboxgl.LngLatBounds();
          features.forEach(feature => {
            if (feature.geometry.type === 'Polygon') {
              feature.geometry.coordinates[0].forEach(coord => bounds.extend(coord));
            } else if (feature.geometry.type === 'MultiPolygon') {
              feature.geometry.coordinates.forEach(polygon =>
                polygon[0].forEach(coord => bounds.extend(coord))
              );
            }
          });
          window.map.fitBounds(bounds, { padding: 50 });
        } else {
          console.warn("Aucune feature trouvée pour les IDs:", selectedIds);
        }
      } catch (error) {
        console.error("Erreur lors de l’application du filtre:", error);
      }

      // Rétablir le clicked si zoom
      window.map.on('zoom', () => {
        if (lastClickedFeatureId) {
          const feature = window.map.querySourceFeatures('iris', {
            sourceLayer: layerConfigs.iris.sourceLayer,
            filter: ['==', ['id'], lastClickedFeatureId]
          })[0];
          if (feature) {
            window.map.setFeatureState(
              { source: 'iris', sourceLayer: layerConfigs.iris.sourceLayer, id: lastClickedFeatureId },
              { clicked: true }
            );
          }
        }
      });
    };


  // 1) Réinitialiser l’éventuel feature cliqué
    // 2) Appliquer setFeatureState
    // 3) Appeler la fonction Bubble
    window.selectGeometry = function(layerId, codeIris) {
      const config = layerConfigs[layerId];
      if (!window.map || !config) return;

      if (lastClickedFeatureId) {
        window.map.removeFeatureState({
          source: layerId,
          sourceLayer: config.sourceLayer
        });
        lastClickedFeatureId = null;
      }

      // Rechercher les features sur *-fill (ou *-outline, c'est pareil en surface)
      const matchingFeatures = window.map.queryRenderedFeatures({
        layers: [layerId + '-fill'],
        filter: ["==", ["get", config.idField], codeIris]
      });

      matchingFeatures.forEach(f => {
        window.map.setFeatureState(
          { source: layerId, sourceLayer: config.sourceLayer, id: f.id },
          { clicked: true }
        );
      });

      if (matchingFeatures.length > 0) {
        lastClickedFeatureId = matchingFeatures[0].id;
      }
      if (typeof bubble_fn_mapClicked === 'function') {
        bubble_fn_mapClicked({
          output1: layerId,
          output2: codeIris
        });
      }
    };



    // Démarrer l’initialisation
    setTimeout(initializeMap, 100);
  </script>
</body>
</html>