<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Carte Mapbox avec sélection des communes et départements</title>
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet">
  <script defer src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
  <script defer src="https://api.mapbox.com/search-js/v1.0.0/web.js"></script>

  <style>
    .my-map-container {
      margin: 0;
      padding: 0;
      font-family: "Inter", sans-serif;
      position: relative;
      width: 100%;
      height: 100%;
    }
    #map {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 100%;
    }
    .legend {
      position: absolute;
      bottom: 20px;
      right: 20px;
      background: rgba(255, 255, 255, 0.9);
      padding: 10px;
      border-radius: 4px;
      font-size: 12px;
    }
    .legend-item {
      display: flex;
      align-items: center;
      margin: 5px 0;
    }
    .legend-color {
      width: 20px;
      height: 20px;
      margin-right: 5px;
    }
    #search-box-container {
      position: absolute;
      top: 16px;
      left: 50%;
      transform: translateX(-50%);
      width: 300px;
      zIndex: 1;
    }
  </style>
</head>
<body>
  <div class="my-map-container">
    <div id="map"></div>
    <div id="search-box-container"></div>
  </div>

  <script>
    /****************************************************
     * Code principal JavaScript pour la carte Mapbox
     ****************************************************/
    window.map = null; // Variable globale unique
    let currentLayerId = null;
    let currentChoropleth = null; 

    const layerConfigs = {
      iris: {
        source: { type: 'vector', url: 'mapbox://hadrienleger.ak5sb828' },
        sourceLayer: 'iris-ign-petite-etendue-wgs84-7y17me',
        basePaint: {
          'fill-color': ['case', ['boolean', ['feature-state', 'clicked'], false], '#d0a4f7', '#7b2cbf'],
          'fill-opacity': 0.7
        },
        idField: 'CODE_IRIS',
        clickable: true,
        useFeatureStateClicked: true,
        isChoropleth: false,
        labels: { enabled: true, field: 'NOM_IRIS', textSize: 12, color: '#FFF', haloColor: '#000', haloWidth: 1 },
        minzoom: 8,
        maxzoom: 22
      },
      niveauVie: {
        source: { type: 'vector', url: 'mapbox://hadrienleger.filosofi2019' },
        sourceLayer: 'c200_filosofi_2019',
        isChoropleth: true,
        property: 'nv_moyen',
        breaks: [15000, 20000, 25000, 30000, 35000],
        colors: ['#fee5d9', '#fcae91', '#fb6a4a', '#de2d26', '#a50f15', '#67000d'],
        opacity: 0.5,
        clickable: false,
        isChoropleth: true,
        labels: { enabled: false }
      },
      log_soc: {
        source: { type: 'vector', url: 'mapbox://hadrienleger.4m17bbun' },
        sourceLayer: 'carte_iris_logsoc_2021-7slbph',
        isChoropleth: true,
        property: 'part_log_soc',
        breaks: [0.039, 0.119, 0.231, 0.38, 0.568, 0.79, 1], // 7 seuils
        colors: ['#10002B', '#240046', '#3C096C', '#5A189A', '#7B2CBF', '9D4EDD', 'C77DFF', 'E0AAFF'], // 8 couleurs
        opacity: 0.5,
        clickable: false,
        isChoropleth: true,
        labels: { enabled: false }
      },
  notesInsecurite: {
  source: { type: 'vector', url: 'mapbox://hadrienleger.7ypxua5r' },
  sourceLayer: 'communes_securite-2449ue',
  isChoropleth: true,
  property: 'note_sur_20',
  breaks: [6.81, 9.71, 11.6, 13.11, 14.64, 17.58, 20], // 7 seuils
  colors: ['#10002B', '#240046', '#3C096C', '#5A189A', '#7B2CBF', '9D4EDD', 'C77DFF', 'E0AAFF'], // 8 couleurs
  opacity: 0.5,
  clickable: false,
  labels: { enabled: true, field: 'note_sur_20', textSize: 12, color: '#333', haloColor: 'rgba(255,255,255,0.8)', haloWidth: 2 },
  minzoom: 8,
  maxzoom: 22
}
    };

    function initializeMap() {
      console.log('Tentative d’initialisation de la carte');
      if (window.map) {
        console.log('Carte déjà initialisée');
        return;
      }
      if (!document.getElementById('map') || typeof mapboxgl === 'undefined') {
        console.log('Mapbox GL JS ou #map non prêt, réessai dans 300ms');
        setTimeout(initializeMap, 300);
        return;
      }

      console.log('Initialisation de la carte...');
      mapboxgl.accessToken = 'pk.eyJ1IjoiaGFkcmllbmxlZ2VyIiwiYSI6ImNsYm1oc3RidzA1NDczdm1xYTJmc3cwcm4ifQ.AguFBTkyTxFnz3VWFBSjrA';
      try {
        window.map = new mapboxgl.Map({
          container: 'map',
          style: 'mapbox://styles/mapbox/streets-v12',
          center: [2.361, 48.852],
          zoom: 10
        });

        window.map.on('load', () => {
          console.log('Carte chargée avec succès');
          Object.keys(layerConfigs).forEach(layerId => {
            if (!window.map.getSource(layerId)) {
              window.map.addSource(layerId, layerConfigs[layerId].source);
            }
          });

          if (typeof mapboxsearch !== 'undefined' && mapboxsearch.MapboxSearchBox) {
            const searchBox = new mapboxsearch.MapboxSearchBox();
            searchBox.accessToken = mapboxgl.accessToken;
            searchBox.options = {
              types: 'address,poi',
              language: 'fr',
              proximity: window.map.getCenter(),
              placeholder: 'Rechercher une adresse ou un lieu'
            };
            searchBox.mapboxgl = mapboxgl;
            searchBox.marker = true;
            searchBox.bindMap(window.map);
            document.getElementById('search-box-container').appendChild(searchBox);

            searchBox.addEventListener('retrieve', (event) => {
              console.log('Résultat de la recherche :', event.detail);
            });
          } else {
            console.warn('Mapbox Search JS non chargé');
          }
        });

        window.map.on('error', (e) => console.error('Erreur Mapbox :', e));
      } catch (error) {
        console.error('Erreur lors de l’initialisation :', error);
      }
    }

   /****************************************************
     * FONCTION hideAllLayers
     * On masque fill, outline et labels
     ****************************************************/
    function hideAllLayers() {  // ****CHANGEMENT****
      if (!window.map) return;
      console.log('=== hideAllLayers called ===');
      Object.keys(layerConfigs).forEach(layerId => {
        // Fill
        if (window.map.getLayer(layerId + '-fill')) {
          window.map.setLayoutProperty(layerId + '-fill', 'visibility', 'none');
        }
        // Outline
        if (window.map.getLayer(layerId + '-outline')) {
          window.map.setLayoutProperty(layerId + '-outline', 'visibility', 'none');
        }
        // Labels
        if (window.map.getLayer(layerId + '-labels')) {
          window.map.setLayoutProperty(layerId + '-labels', 'visibility', 'none');
        }
      });
    }
    window.hideAllLayers = hideAllLayers;

function addLayer(layerId) {
  const config = layerConfigs[layerId];
  if (!config || !window.map) return;

  if (!window.map.loaded()) {
    console.log(`Carte non chargée pour ${layerId}, attente...`);
    window.map.once('load', () => addLayer(layerId));
    return;
  }

  // Vérifier si le fill est déjà présent (on suppose qu'on crée fill+outline en même temps)
  if (window.map.getLayer(layerId + '-fill')) {
    return; // La couche est déjà là
  }

  console.log(`Ajout de la couche: ${layerId} (fill + outline)`);

  // 1) Calculer la palette de couleurs si c'est un choropleth
  let fillPaintObj;
  if (config.isChoropleth) {
    const colorExpr = ["step", ["get", config.property], config.colors[0]];
    config.breaks.forEach((brk, i) => {
      colorExpr.push(brk);
      colorExpr.push(config.colors[i + 1]);
    });
    fillPaintObj = {
      'fill-color': colorExpr,
      'fill-opacity': config.opacity ?? 0.7
      // On ne met PAS fill-outline-color ici, on va le gérer en "line" plus bas
    };
    console.log('Expression choroplèthe:', colorExpr);
  } else {
    fillPaintObj = config.basePaint ? { ...config.basePaint } : {
      'fill-color': '#2C3E50',
      'fill-opacity': 0.8
      // idem, pas de fill-outline-color
    };
    if (config.useFeatureStateClicked) {
      fillPaintObj['fill-color'] = [
        'case',
        ['boolean', ['feature-state', 'clicked'], false],
        '#d0a4f7',
        fillPaintObj['fill-color']
      ];
    }
  }

  // 2) Ajouter le calque "fill" (ex: "iris-fill") avant "settlement-subdivision-label"
  const fillLayerId = layerId + '-fill';
  try {
    window.map.addLayer({
      id: fillLayerId,
      type: 'fill',
      source: layerId,                      // La source vectorielle porte le même nom que "layerId"
      'source-layer': config.sourceLayer,
      minzoom: config.minzoom,
      maxzoom: config.maxzoom,
      paint: fillPaintObj
    }, 'settlement-subdivision-label');
    console.log(`Couche fill ${fillLayerId} ajoutée (avant settlement-subdivision-label)`);
  } catch (error) {
    console.error(`Erreur lors de l’ajout du fill pour ${layerId}:`, error);
  }

  // 3) Ajouter un calque "line" (ex: "iris-outline") pour le contour
  const outlineLayerId = layerId + '-outline';
  try {
    window.map.addLayer({
      id: outlineLayerId,
      type: 'line',
      source: layerId,
      'source-layer': config.sourceLayer,
      minzoom: config.minzoom,
      maxzoom: config.maxzoom,
      paint: {
        'line-color': '#FFFFFF',  // Contour blanc
        'line-width': 1,         // Épaisseur
        'line-opacity': 0.8,
        'line-blur': 0,          // Tu peux tester un léger blur (ex: 0.3)
      },
      layout: {
        'line-join': 'round',    // bords arrondis
        'line-cap': 'round'
      }
    }, 'settlement-subdivision-label');
    console.log(`Couche outline ${outlineLayerId} ajoutée (avant settlement-subdivision-label)`);
  } catch (error) {
    console.error(`Erreur lors de l’ajout de l’outline pour ${layerId}:`, error);
  }

  // 4) Ajouter éventuellement les labels
  if (config.labels?.enabled) {
    const labelLayerId = `${layerId}-labels`;
    try {
      window.map.addLayer({
        id: labelLayerId,
        type: 'symbol',
        source: layerId,
        'source-layer': config.sourceLayer,
        layout: {
          'text-field': ['get', config.labels.field],
          'text-size': config.labels.textSize || 12,
          'text-anchor': 'center'
        },
        paint: {
          'text-color': config.labels.color || '#000',
          'text-halo-color': config.labels.haloColor || '#fff',
          'text-halo-width': config.labels.haloWidth || 1
        }
      }, 'settlement-subdivision-label');
    } catch (error) {
      console.error(`Erreur lors de l’ajout des labels pour ${layerId}:`, error);
    }
  }

  // 5) Gérer le “clickable” sur le fill layer
  //    => On attache les events sur (layerId + '-fill'), pas sur le line.
  if (config.clickable) {
    window.map.on('click', fillLayerId, e => handleLayerClick(e, layerId));
    window.map.on('mouseenter', fillLayerId, () => window.map.getCanvas().style.cursor = 'pointer');
    window.map.on('mouseleave', fillLayerId, () => window.map.getCanvas().style.cursor = '');
  }
}


    let lastClickedFeatureId = null;

    function handleLayerClick(e, layerId) {
      const config = layerConfigs[layerId];
      if (!config || !e.features[0]) return;

      const feature = e.features[0];
      const codeIris = feature.properties[config.idField];
      window.selectGeometry(layerId, codeIris);  // <--- On réutilise la fonction commune
    }

    window.updateMapLayers = function(layerId) {
          if (!window.map) return;
          if (!window.map.loaded()) {
            window.map.once('load', () => window.updateMapLayers(layerId));
            return;
          }

          const config = layerConfigs[layerId];
          addLayer(layerId);

          // Rendre visible le fill
          if (window.map.getLayer(layerId + '-fill')) {
            window.map.setLayoutProperty(layerId + '-fill', 'visibility', 'visible');
          }
          // Rendre visible l’outline
          if (window.map.getLayer(layerId + '-outline')) {
            window.map.setLayoutProperty(layerId + '-outline', 'visibility', 'visible');
          }
          // Rendre visible les labels
          if (config?.labels?.enabled && window.map.getLayer(layerId + '-labels')) {
            window.map.setLayoutProperty(layerId + '-labels', 'visibility', 'visible');
          }
        };


    // Gestion des couches choropleths
  /****************************************************
     * showChoroplethLayer(layerId)
     * => exclusif : on masque l'ancien + on affiche le nouveau
     ****************************************************/
    window.showChoroplethLayer = function(layerId) { // ****CHANGEMENT****
      if (!window.map) return;
      if (!window.map.loaded()) {
        window.map.once('load', () => window.showChoroplethLayer(layerId));
        return;
      }
      const config = layerConfigs[layerId];
      if (!config || !config.isChoropleth) {
        console.warn(`${layerId} n’est pas un choroplèthe`);
        return;
      }

      // Masquer le choropleth actuel
      if (currentChoropleth && currentChoropleth !== layerId) {
        const oldConfig = layerConfigs[currentChoropleth];
        // On masque fill, outline et labels
        if (window.map.getLayer(currentChoropleth + '-fill')) {
          window.map.setLayoutProperty(currentChoropleth + '-fill', 'visibility', 'none');
        }
        if (window.map.getLayer(currentChoropleth + '-outline')) {
          window.map.setLayoutProperty(currentChoropleth + '-outline', 'visibility', 'none');
        }
        if (oldConfig?.labels?.enabled && window.map.getLayer(currentChoropleth + '-labels')) {
          window.map.setLayoutProperty(currentChoropleth + '-labels', 'visibility', 'none');
        }
        currentChoropleth = null;
      }

      // Afficher ce choropleth
      window.updateMapLayers(layerId);
      currentChoropleth = layerId;
    };

    /****************************************************
     * hideChoropleth()
     * => masque le choropleth actif
     ****************************************************/
    window.hideChoropleth = function() { // ****CHANGEMENT****
      if (!currentChoropleth) return;
      const oldConfig = layerConfigs[currentChoropleth];
      // fill
      if (window.map.getLayer(currentChoropleth + '-fill')) {
        window.map.setLayoutProperty(currentChoropleth + '-fill', 'visibility', 'none');
      }
      // outline
      if (window.map.getLayer(currentChoropleth + '-outline')) {
        window.map.setLayoutProperty(currentChoropleth + '-outline', 'visibility', 'none');
      }
      // labels
      if (oldConfig?.labels?.enabled && window.map.getLayer(currentChoropleth + '-labels')) {
        window.map.setLayoutProperty(currentChoropleth + '-labels', 'visibility', 'none');
      }
      currentChoropleth = null;
    };




    // On-off d'une couche donnée (hors couches choropleths qui sont gérées par les fonctions showChoropleth et hideChoropleth, vu que les couches chorpoleths sont exclusives)
   window.toggleLayer = function(layerId) { // ****CHANGEMENT****
      const config = layerConfigs[layerId];
      if (!config) return;

      if (config.isChoropleth) {
        console.warn("toggleLayer est conçu pour des layers non-choropleth. Utilise showChoroplethLayer.");
        return;
      }

      addLayer(layerId);

      // On se base sur la visibilité du fill pour décider
      const fillVisibility = window.map.getLayer(layerId + '-fill')
        ? window.map.getLayoutProperty(layerId + '-fill', 'visibility')
        : 'none';
      const newVisibility = (fillVisibility === 'visible') ? 'none' : 'visible';

      // fill
      if (window.map.getLayer(layerId + '-fill')) {
        window.map.setLayoutProperty(layerId + '-fill', 'visibility', newVisibility);
      }
      // outline
      if (window.map.getLayer(layerId + '-outline')) {
        window.map.setLayoutProperty(layerId + '-outline', 'visibility', newVisibility);
      }
      // labels
      if (config.labels?.enabled && window.map.getLayer(layerId + '-labels')) {
        window.map.setLayoutProperty(layerId + '-labels', 'visibility', newVisibility);
      }
    };


    /****************************************************
     * filterIRIS(irisString)
     * => on veut appliquer un filtre sur la couche "iris"
     *    => donc on rend "iris-fill" et "iris-outline"
     *       visibles, on setFilter() sur 'iris-fill' + 'iris-outline' + 'iris-labels'
     ****************************************************/
    window.filterIRIS = function(irisString) { // ****CHANGEMENT****
      if (!window.map) {
        console.log("Carte non initialisée, réessai dans 300ms");
        setTimeout(() => window.filterIRIS(irisString), 300);
        return;
      }

      if (!window.map.loaded()) {
        console.log("Carte non chargée, attente de l’événement 'load'...");
        window.map.once('load', () => window.filterIRIS(irisString));
        return;
      }

      console.log("Application du filtre IRIS avec:", irisString);
      if (lastClickedFeatureId) {
        window.map.removeFeatureState({ source: 'iris', sourceLayer: layerConfigs.iris.sourceLayer });
        lastClickedFeatureId = null;
      }

      let selectedIds = typeof irisString === 'string'
        ? irisString.split(',').map(item => item.trim())
        : irisString;

      hideAllLayers(); // on masque tout

      // Vérifier la source
      if (!window.map.getSource('iris')) {
        console.error("Source 'iris' non trouvée, ajout en cours...");
        window.map.addSource('iris', layerConfigs.iris.source);
      }

      // Ajouter la couche IRIS si besoin
      addLayer('iris');

      // Rendre visible fill, outline, labels
      if (window.map.getLayer('iris-fill')) {
        window.map.setLayoutProperty('iris-fill', 'visibility', 'visible');
      }
      if (window.map.getLayer('iris-outline')) {
        window.map.setLayoutProperty('iris-outline', 'visibility', 'visible');
      }
      if (window.map.getLayer('iris-labels')) {
        window.map.setLayoutProperty('iris-labels', 'visibility', 'visible');
      }

      // Appliquer un setFilter pour restreindre aux IRIS listés
      try {
        const filter = ['match', ['get', 'CODE_IRIS'], selectedIds, true, false];
        if (window.map.getLayer('iris-fill')) {
          window.map.setFilter('iris-fill', filter);
        }
        if (window.map.getLayer('iris-outline')) {
          window.map.setFilter('iris-outline', filter);
        }
        if (window.map.getLayer('iris-labels')) {
          window.map.setFilter('iris-labels', filter);
        }

        // On calcule le bounding box pour l'ensemble
        const features = window.map.querySourceFeatures('iris', {
          sourceLayer: layerConfigs.iris.sourceLayer,
          filter
        });
        if (features.length > 0) {
          const bounds = new mapboxgl.LngLatBounds();
          features.forEach(feature => {
            if (feature.geometry.type === 'Polygon') {
              feature.geometry.coordinates[0].forEach(coord => bounds.extend(coord));
            } else if (feature.geometry.type === 'MultiPolygon') {
              feature.geometry.coordinates.forEach(polygon =>
                polygon[0].forEach(coord => bounds.extend(coord))
              );
            }
          });
          window.map.fitBounds(bounds, { padding: 50 });
        } else {
          console.warn("Aucune feature trouvée pour les IDs:", selectedIds);
        }
      } catch (error) {
        console.error("Erreur lors de l’application du filtre:", error);
      }

      // Rétablir le clicked si zoom
      window.map.on('zoom', () => {
        if (lastClickedFeatureId) {
          const feature = window.map.querySourceFeatures('iris', {
            sourceLayer: layerConfigs.iris.sourceLayer,
            filter: ['==', ['id'], lastClickedFeatureId]
          })[0];
          if (feature) {
            window.map.setFeatureState(
              { source: 'iris', sourceLayer: layerConfigs.iris.sourceLayer, id: lastClickedFeatureId },
              { clicked: true }
            );
          }
        }
      });
    };


  // 1) Réinitialiser l’éventuel feature cliqué
    // 2) Appliquer setFeatureState
    // 3) Appeler la fonction Bubble
    window.selectGeometry = function(layerId, codeIris) {
      const config = layerConfigs[layerId];
      if (!window.map || !config) return;

      if (lastClickedFeatureId) {
        window.map.removeFeatureState({
          source: layerId,
          sourceLayer: config.sourceLayer
        });
        lastClickedFeatureId = null;
      }

      // Rechercher les features sur *-fill (ou *-outline, c'est pareil en surface)
      const matchingFeatures = window.map.queryRenderedFeatures({
        layers: [layerId + '-fill'],
        filter: ["==", ["get", config.idField], codeIris]
      });

      matchingFeatures.forEach(f => {
        window.map.setFeatureState(
          { source: layerId, sourceLayer: config.sourceLayer, id: f.id },
          { clicked: true }
        );
      });

      if (matchingFeatures.length > 0) {
        lastClickedFeatureId = matchingFeatures[0].id;
      }
      if (typeof bubble_fn_mapClicked === 'function') {
        bubble_fn_mapClicked({
          output1: layerId,
          output2: codeIris
        });
      }
    };



    // Démarrer l’initialisation
    setTimeout(initializeMap, 100);
  </script>
</body>
</html>