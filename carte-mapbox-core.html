<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Carte Mapbox avec s√©lection des communes et d√©partements</title>
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet">
  <script defer src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
  <script defer src="https://api.mapbox.com/search-js/v1.0.0/web.js"></script>
  <!-- Turf pour g√©n√©rer le cercle du second mode de recherche -->
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>

  <style>
    .my-map-container {
      margin: 0;
      padding: 0;
      font-family: "Inter", sans-serif;
      position: relative;
      width: 100%;
      height: 100%;
    }
    #map {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 100%;
    }
    .legend {
      position: absolute;
      bottom: 20px;
      right: 20px;
      background: rgba(255, 255, 255, 0.9);
      padding: 10px;
      border-radius: 4px;
      font-size: 12px;
    }
    .legend-item {
      display: flex;
      align-items: center;
      margin: 5px 0;
    }
    .legend-color {
      width: 20px;
      height: 20px;
      margin-right: 5px;
    }
    #search-box-container {
      position: absolute;
      top: 16px;
      left: 50%;
      transform: translateX(-50%);
      width: 300px;
      zIndex: 1;
    }

  </style>
</head>
<body>
  <div class="my-map-container">
    <div id="map"></div>
    <div id="search-box-container"></div>
  </div>

  <script>
    /****************************************************
     * Code principal JavaScript pour la carte Mapbox
     ****************************************************/
    window.map = null; // Variable globale unique
    window.collectivitesData = { type: 'FeatureCollection', features: [] }; // Stocke les donn√©es GeoJSON des collectivit√©s
    window.radiusData = { type: 'FeatureCollection', features: [] }; // Stocke le GeoJSON du cercle    let currentLayerId = null;
    let currentChoropleth = null; 

    const layerConfigs = {
      iris: {
        source: { type: 'vector', url: 'mapbox://hadrienleger.ak5sb828' },
        sourceLayer: 'iris-ign-petite-etendue-wgs84-7y17me',
        basePaint: {
          'fill-color': ['case', ['boolean', ['feature-state', 'clicked'], false], '#d0a4f7', '#7b2cbf'],
          'fill-opacity': 0.7
        },
        idField: 'CODE_IRIS',
        clickable: true,
        useFeatureStateClicked: true,
        isChoropleth: false,
        labels: { enabled: true, field: 'NOM_IRIS', textSize: 12, color: '#FFF', haloColor: '#000', haloWidth: 1 },
        minzoom: 8,
        maxzoom: 22
      },
      rev_decl: {
        source: { type: 'vector', url: 'mapbox://hadrienleger.2s705opr' },
        sourceLayer: 'carte_iris_revdecl_2021-dugg0i',
        isChoropleth: true,
        property: 'mediane_rev_decl',
        breaks: [17370, 22660, 27960, 37840, 77180], // 5 seuils
        colors: ['#eff3ff', '#c6dbef', '#9ecae1', '#6baed6', '#08519c', '#08519c'], // 6 couleurs
        nullColor: '#d3d3d3', // Gris clair pour les valeurs nulles
        opacity: 0.8,
        clickable: false,
        isChoropleth: true,
        labels: {
        enabled: true,
        field: 'mediane_rev_decl',
        textSize: 12,
        color: '#333',
        haloColor: 'rgba(255,255,255,0.8)',
        haloWidth: 2,
        labelFormat: 'currency-euro',
        minzoom: 12
         },
        minzoom: 8,
        maxzoom: 22
      },
      log_soc: {
        source: { type: 'vector', url: 'mapbox://hadrienleger.4m17bbun' },
        sourceLayer: 'carte_iris_logsoc_2021-7slbph',
        isChoropleth: true,
        property: 'part_log_soc',
        breaks: [0.065, 0.2, 0.41, 0.695, 1], // 5 seuils
        colors: ['#eff3ff', '#c6dbef', '#9ecae1', '#6baed6', '#08519c', '#08519c'], // 6 couleurs
        nullColor: '#d3d3d3', // Gris clair pour les valeurs nulles
        opacity: 0.8,
        clickable: false,
        isChoropleth: true,
        labels: {
        enabled: true,
        field: 'part_log_soc',
        textSize: 12,
        color: '#333',
        haloColor: 'rgba(255,255,255,0.8)',
        haloWidth: 2,
        labelFormat: 'percent-0'
        },
        minzoom: 8,
        maxzoom: 22
      },
      notesInsecurite: {
      source: { type: 'vector', url: 'mapbox://hadrienleger.7ypxua5r' },
      sourceLayer: 'communes_securite-2449ue',
      isChoropleth: true,
      property: 'note_sur_20',
      breaks: [8.32, 11.46, 13.67, 17.33, 20], // 5 seuils
      colors: ['#eff3ff', '#c6dbef', '#9ecae1', '#6baed6', '#08519c', '#08519c'], // 6 couleurs
      nullColor: '#d3d3d3', // Gris clair pour les valeurs nulles
      opacity: 0.8,
      clickable: false,
      labels: {
        enabled: true,
        field: 'note_sur_20',
        textSize: 12,
        color: '#333',
        haloColor: 'rgba(255,255,255,0.8)',
        haloWidth: 2,
        labelFormat: 'number-1'
      },
      minzoom: 8,
      maxzoom: 22
    }
    };

///// ZONE DE RECHERCHE //////
/* ---------- fonctions globales appel√©es par Bubble ---------- */
let   globalBounds = null;     /* ‚Üê plus d‚Äôappel direct √† mapboxgl ici */
const collectiviteCodes = new Set();   // Pour suivre ce qui est affich√©

/* Affiche les polygones des collectivit√©s choisies */
window.showCollectivitePolygons = function(fc) {
  if (!window.map) {
    console.warn("üõë Map not initialized for showCollectivitePolygons");
    return;
  }

  // Sauvegarder les donn√©es
  window.collectivitesData = fc;
  console.log("‚úÖ Saved collectivites data:", fc.features.length, "features");

  // Ajouter ou mettre √† jour la source
  if (window.map.getSource('collectivites')) {
    window.map.getSource('collectivites').setData(fc);
  } else {
    window.map.addSource('collectivites', { type: 'geojson', data: fc });
    window.map.addLayer({
      id: 'collectivites-fill',
      type: 'fill',
      source: 'collectivites',
      paint: { 'fill-color': '#8A2BE2', 'fill-opacity': 0.25 }
    });
    window.map.addLayer({
      id: 'collectivites-outline',
      type: 'line',
      source: 'collectivites',
      paint: { 'line-color': '#8A2BE2', 'line-width': 2 }
    });
  }

  // M√©moriser les codes
  fc.features.forEach(f => collectiviteCodes.add(f.properties.code_insee));
  console.log("‚úÖ Updated collectiviteCodes:", Array.from(collectiviteCodes));

  // Calculer fitBounds
  const bbox = turf.bbox(fc);
  window.map.fitBounds(bbox, { padding: 60, duration: 600 });
};

window.removeCollectivite = function(code){
  if (!collectiviteCodes.has(code)) return;
  collectiviteCodes.delete(code);

  // Filtrer les features restantes
  const remaining = { type:'FeatureCollection',
                      features: Array.from(collectiviteCodes).map(c => {
                        return window.map.getSource('collectivites')
                                         ._data.features
                                         .find(f => f.properties.code_insee === c);
                      }).filter(Boolean) };

  // Mettre √† jour la source
  window.map.getSource('collectivites').setData(remaining);

  // Refit si encore des polygones
  if (remaining.features.length){
    const bbox = turf.bbox(remaining);
    window.map.fitBounds(bbox,{ padding:60, duration:600 });
  }
};

window.removeAllCollectivites = function(){
  collectiviteCodes.clear();
  if (window.map && window.map.getSource('collectivites')){
    window.map.removeLayer('collectivites-fill');
    window.map.removeLayer('collectivites-outline');
    window.map.removeSource('collectivites');
  }
};

///// FIN DE LA PARTIE ZONE DE RECHERCHE /////

    function initializeMap() {
      console.log('Tentative d‚Äôinitialisation de la carte');
      if (window.map) {
        console.log('Carte d√©j√† initialis√©e');
        return;
      }
      if (!document.getElementById('map') || typeof mapboxgl === 'undefined') {
        console.log('Mapbox GL JS ou #map non pr√™t, r√©essai dans 300ms');
        setTimeout(initializeMap, 300);
        return;
      }

      console.log('Initialisation de la carte...');
      mapboxgl.accessToken = 'pk.eyJ1IjoiaGFkcmllbmxlZ2VyIiwiYSI6ImNtYXBjbDlzYTBncGoyaXNhN3dpajI3b3MifQ.TatwRPDuazMQH2DfSkxv2w';
      try {
        window.map = new mapboxgl.Map({
          container: 'map',
          style: 'mapbox://styles/mapbox/streets-v12',
          center: [2.361, 48.852],
          zoom: 10
        });

        window.map.on('load', () => {
          console.log('Carte charg√©e avec succ√®s');
          Object.keys(layerConfigs).forEach(layerId => {
            if (!window.map.getSource(layerId)) {
              window.map.addSource(layerId, layerConfigs[layerId].source);
            }
          });

          if (typeof mapboxsearch !== 'undefined' && mapboxsearch.MapboxSearchBox) {
            const searchBox = new mapboxsearch.MapboxSearchBox();
            searchBox.accessToken = mapboxgl.accessToken;
            searchBox.options = {
              types: 'address,poi',
              language: 'fr',
              proximity: window.map.getCenter(),
              placeholder: 'Rechercher une adresse ou un lieu'
            };
            searchBox.mapboxgl = mapboxgl;
            searchBox.marker = false;
            searchBox.bindMap(window.map);
            document.getElementById('search-box-container').appendChild(searchBox);

            searchBox.addEventListener('retrieve', (event) => {
              console.log('R√©sultat de la recherche :', event.detail);
              const [lon, lat] = event.detail.features[0].geometry.coordinates;

              // 1. Centrer / marquer
              window.map.flyTo({ center: [lon, lat], zoom: 15 });
              new mapboxgl.Marker({ color:'#ff0066' })
                .setLngLat([lon, lat])
                .addTo(window.map);

              // 2. Passer l'info √† Bubble
              if (typeof bubble_fn_addressSelected === 'function') {
                bubble_fn_addressSelected({
                  output1: lon,
                  output2: lat });
              }
            });
          } else {
            console.warn('Mapbox Search JS non charg√©');
          }
        });

        window.map.on('error', (e) => console.error('Erreur Mapbox :', e));
      } catch (error) {
        console.error('Erreur lors de l‚Äôinitialisation :', error);
      }
    }

// PARAMETRAGE DES SEARCHBOX EXTERNALISEES

// Param√©trage du rayon (Trouver / Second mode de recherche)
/* -------- variables globales pour ce mode -------- */
window.radiusCenter = null;   // {lon,lat}
window.radiusKm     = 5;      // distance en km

/* Cr√©e le cercle ou le met √† jour */
function drawRadius() {
  console.log("‚û°Ô∏è drawRadius called with:", { center: window.radiusCenter, radiusKm: window.radiusKm });

  if (!window.map || !window.map.loaded()) {
    console.warn("üõë Cannot draw radius: map not loaded");
    return;
  }

  if (!window.radiusCenter || typeof window.radiusCenter.lon !== 'number' || typeof window.radiusCenter.lat !== 'number') {
    console.warn("üõë Cannot draw radius: invalid or missing radiusCenter");
    return;
  }

  if (typeof window.radiusKm !== 'number' || window.radiusKm <= 0) {
    console.warn("üõë Cannot draw radius: invalid or missing radiusKm, using default 5km");
    window.radiusKm = 5; // Valeur par d√©faut
  }

  // G√©n√©rer le GeoJSON du cercle
  let geojson;
  try {
    const circleFeature = turf.circle([window.radiusCenter.lon, window.radiusCenter.lat], window.radiusKm, { steps: 64, units: 'kilometers' });
    geojson = {
      type: 'FeatureCollection',
      features: [circleFeature]
    };
  } catch (error) {
    console.error("üõë Error generating circle GeoJSON:", error);
    geojson = { type: 'FeatureCollection', features: [] };
  }

  // Sauvegarder dans window.radiusData
  window.radiusData = geojson;
  console.log("‚úÖ Saved radius data:", geojson.features.length, "features");

  // Mettre √† jour ou cr√©er la source et les couches
  if (window.map.getSource('radius')) {
    window.map.getSource('radius').setData(geojson);
    console.log("üîç Updated radius source");
  } else {
    try {
      window.map.addSource('radius', { type: 'geojson', data: geojson });
      window.map.addLayer({
        id: 'radius-fill',
        type: 'fill',
        source: 'radius',
        paint: { 'fill-color': '#8A2BE2', 'fill-opacity': 0.2 }
      });
      window.map.addLayer({
        id: 'radius-outline',
        type: 'line',
        source: 'radius',
        paint: { 'line-color': '#8A2BE2', 'line-width': 2 }
      });
      console.log("‚ûï Added radius source and layers");
    } catch (error) {
      console.error("üõë Error adding radius source or layers:", error);
    }
  }
}

/* Expos√© √† Bubble : change la distance (km) */
window.updateRadius = function(km) {
  console.log("‚û°Ô∏è updateRadius called with:", km);
  if (typeof km !== 'number' || isNaN(km) || km <= 0) {
    console.warn("üõë Invalid radius value, using default 5km");
    window.radiusKm = 5;
  } else {
    window.radiusKm = km;
  }
  drawRadius();
};

/* Expos√© √† Bubble : efface tout (si onglet switch) */
window.clearRadius = function() {
  console.log("‚û°Ô∏è clearRadius called");

  // 1. Supprimer le cercle s‚Äôil existe
  if (window.map && window.map.getSource('radius')) {
    if (window.map.getLayer('radius-fill')) {
      window.map.removeLayer('radius-fill');
      console.log("‚úÖ Removed radius-fill layer");
    }
    if (window.map.getLayer('radius-outline')) {
      window.map.removeLayer('radius-outline');
      console.log("‚úÖ Removed radius-outline layer");
    }
    window.map.removeSource('radius');
    console.log("‚úÖ Removed radius source");
  }

  // 2. Supprimer le marqueur centre s‚Äôil existe
  if (window.radiusMarker) {
    window.radiusMarker.remove();
    window.radiusMarker = null;
    console.log("‚úÖ Removed radius marker");
  }

  // 3. R√©initialiser les variables
  window.radiusCenter = null;
  window.radiusKm = null;
  window.radiusData = { type: 'FeatureCollection', features: [] };
  console.log("‚úÖ Reset radius variables and data");
};


/* -------------------------------------------------- */
/*  A)  SearchBox ¬´ Trouver ¬ª    */
/* -------------------------------------------------- */
function initExternalSearch_Trouver() {
  if (!document.getElementById('radius-search') || !window.map) {
    console.log("Waiting for radius-search or map to be ready...");
    setTimeout(initExternalSearch_Trouver, 300);
    return;
  }

  const sb = new mapboxsearch.MapboxSearchBox();
  sb.accessToken = mapboxgl.accessToken;
  sb.options = { types: 'address,poi', language: 'fr', placeholder: 'Tapez une adresse ou le nom d\'un lieu' };
  sb.mapboxgl = mapboxgl;
  sb.marker = false;
  sb.bindMap(window.map);

  const host = document.getElementById('radius-search');  // le placeholder Bubble
  host.innerHTML = '';            // au cas o√π
  host.appendChild(sb);           // <-- c‚Äôest cette ligne qui manquait
  sb.style.width = '100%';        // pleine largeur

  sb.addEventListener('retrieve', e => {
    const [lon, lat] = e.detail.features[0].geometry.coordinates;

    // 1. Stocker le centre
    window.radiusCenter = { lon, lat };
    // D√©finir un rayon par d√©faut si non d√©fini
    if (typeof window.radiusKm !== 'number' || window.radiusKm <= 0) {
      window.radiusKm = 5; // Rayon par d√©faut
      console.log("‚úÖ Set default radiusKm to 5");
    }

    // 2. Placer (ou d√©placer) le marqueur central
    if (!window.radiusMarker) {
      window.radiusMarker = new mapboxgl.Marker({ color: '#8A2BE2' })
        .setLngLat([lon, lat])
        .addTo(window.map);
    } else {
      window.radiusMarker.setLngLat([lon, lat]);
    }

    // 3. Dessiner / mettre √† jour le cercle
    drawRadius();

    // 4. Informer Bubble
    if (typeof bubble_fn_pointMapboxSearchAPI === 'function') {
      bubble_fn_pointMapboxSearchAPI({ output1: lon, output2: lat });
    }
  });

  sb.addEventListener('clear', () => {
    // 1. Retirer le marqueur centre s‚Äôil existe
    if (window.radiusMarker) {
      window.radiusMarker.remove();
      window.radiusMarker = null;
    }
    // 2. Effacer le cercle et r√©initialiser les variables
    window.clearRadius();
  });
}

initExternalSearch_Trouver();   // lance l‚Äôattente

/* -------------------------------------------------- */
/*  FIN A)  SearchBox ¬´ Trouver ¬ª                     */
/* -------------------------------------------------- */

/* -------------------------------------------------- */
/*  B)  SearchBox ¬´ Explorer ¬ª ‚Äì centr√©e et focus     */
/* -------------------------------------------------- */

function initExternalSearch_Explorer () {
  const anchor = document.getElementById('mapbox-searchbox');          // le faux HTML
  const host   = document.getElementById('global-searchbox-container'); // le groupe Bubble

  if (!anchor || !host || !window.map) {
    setTimeout(initExternalSearch_Explorer, 300);
    return;
  }

  /* 1. Cr√©e la SearchBox Mapbox */
  const sb = new mapboxsearch.MapboxSearchBox();
  sb.accessToken = mapboxgl.accessToken;
  sb.options = {
    types       : 'address,poi',
    language    : 'fr',
    placeholder : 'Tapez une adresse ou un lieu'
  };
  sb.mapboxgl = mapboxgl;
  sb.marker   = false;
  sb.bindMap(window.map);

  /* 2. Vide le conteneur puis ins√®re la SearchBox */
  host.innerHTML = '';          // ‚ö†Ô∏è on enl√®ve le placeholder qui bloquait les clics
  host.appendChild(sb);

  /* 3. Style du conteneur : reste dans le flux, centre le contenu */
  Object.assign(host.style, {
    position       : 'relative',   // le groupe reste ‚Äúnormal‚Äù
    display        : 'flex',
    alignItems     : 'center',     // centre verticalement
    justifyContent : 'center',     // centre horizontalement
    pointerEvents  : 'auto',       // re√ßoit bien les clics
    zIndex         : 3000          // au-dessus des autres groupes Bubble
  });

  /* 4. Style de la SearchBox elle-m√™me */
  sb.style.width = '100%';        // occupe toute la largeur du groupe
  sb.style.minWidth = '280px';    // limite max si tu veux
  sb.style.maxWidth = '600px';    // limite max si tu veux

  /* 5. Le dropdown doit rester devant tout */
  const style = document.createElement('style');
  style.textContent = `
    .mapbox-searchbox__suggestions { z-index: 99999 !important; }
    .mapbox-searchbox              { z-index: 99998 !important; }
  `;
  document.head.appendChild(style);

  /* 6. Callbacks vers Bubble */
sb.addEventListener('retrieve', e => {
  const [lon, lat] = e.detail.features[0].geometry.coordinates;

  /* A) centrer / zoomer */
  window.map.flyTo({ center: [lon, lat], zoom: 15 });

  /* B) placer ou d√©placer le marqueur  üÜï */
  if (!window.addressMarker) {
    window.addressMarker = new mapboxgl.Marker({ color: '#ff0066' })  // rose fuchsia ?
                              .setLngLat([lon, lat])
                              .addTo(window.map);
  } else {
    window.addressMarker.setLngLat([lon, lat]);
  }

  /* C) pr√©venir Bubble (inchang√©) */
    if (typeof bubble_fn_pointMapboxSearchAPI === 'function') {
      bubble_fn_pointMapboxSearchAPI({ output1: lon, output2: lat });
    }
});

  /* D) Suppression du marqueur */
  sb.addEventListener('clear', () => {
    if (window.addressMarker) {
      window.addressMarker.remove();
      window.addressMarker = null;
    }
});


  console.log('‚úÖ SearchBox externe initialis√©e ‚Äì centr√©e et 100 % cliquable');
}

initExternalSearch_Explorer();  // lance l‚Äôattente

/* -------------------------------------------------- */
/*  FIN B)  SearchBox ¬´ Explorer ¬ª ‚Äì centr√©e et focus     */
/* -------------------------------------------------- */

/* =========  UTILITAIRE  ========== */
/* =========  UTILITAIRE : rend iris-fill / iris-temp cliquables  ========== */
/* =========  UTILITAIRE : capter les clics sur iris-fill et iris-temp  ========== */
function registerIrisClickListeners() {
  ['iris-fill', 'iris-temp'].forEach(layerId => {
    if (window.map.getLayer(layerId) && !window.map.listens?.('click', layerId)) {
      window.map.on('click', layerId, e => {
        const codeIris = e.features[0].properties['CODE_IRIS'];
        window.selectGeometry('iris', codeIris);
      });
      window.map.on('mouseenter', layerId, () =>
        window.map.getCanvas().style.cursor = 'pointer');
      window.map.on('mouseleave', layerId, () =>
        window.map.getCanvas().style.cursor = '');
    }
  });
}

   /****************************************************
     * FONCTION hideAllLayers
     * On masque fill, outline et labels
     ****************************************************/
    function hideAllLayers() {  // ****CHANGEMENT****
      if (!window.map) return;
      console.log('=== hideAllLayers called ===');
      Object.keys(layerConfigs).forEach(layerId => {
        // Fill
        if (window.map.getLayer(layerId + '-fill')) {
          window.map.setLayoutProperty(layerId + '-fill', 'visibility', 'none');
        }
        // Outline
        if (window.map.getLayer(layerId + '-outline')) {
          window.map.setLayoutProperty(layerId + '-outline', 'visibility', 'none');
        }
        // Labels
        if (window.map.getLayer(layerId + '-labels')) {
          window.map.setLayoutProperty(layerId + '-labels', 'visibility', 'none');
        }
      });
    }
    window.hideAllLayers = hideAllLayers;

function addLayer(layerId) {
  const config = layerConfigs[layerId];
  if (!config || !window.map) return;

  console.log(`Ajout ou mise √† jour de ${layerId} (fill + outline)`);

  // V√©rifier si la source existe, sinon l‚Äôajouter
  if (!window.map.getSource(layerId)) {
    console.log(`Source ${layerId} absente, ajout...`);
    try {
      window.map.addSource(layerId, config.source);
      console.log(`Source ${layerId} ajout√©e`);
    } catch (error) {
      console.error(`Erreur lors de l‚Äôajout de la source ${layerId}:`, error);
      return;
    }
  }

let fillPaintObj;
  if (config.isChoropleth) {
    // Expression pour g√©rer les valeurs nulles dans la couleur
    const colorExpr = [
      'case',
      ['==', ['get', config.property], null], config.nullColor || '#d3d3d3', // Couleur pour null
      ['step', ['get', config.property], config.colors[0], ...config.breaks.flatMap((brk, i) => [brk, config.colors[i + 1]])]
    ];
    fillPaintObj = {
      'fill-color': colorExpr,
      'fill-opacity': config.opacity ?? 0.7
    };
    console.log(`Expression choropl√®the pour ${layerId}:`, colorExpr);
  } else {
    fillPaintObj = config.basePaint ? { ...config.basePaint } : {
      'fill-color': '#2C3E50',
      'fill-opacity': 0.8
    };
    if (config.useFeatureStateClicked) {
      fillPaintObj['fill-color'] = [
        'case',
        ['boolean', ['feature-state', 'clicked'], false],
        '#d0a4f7',
        fillPaintObj['fill-color']
      ];
    }
  }

  const fillLayerId = layerId + '-fill';
  if (window.map.getLayer(fillLayerId)) {
    console.log(`Couche ${fillLayerId} d√©j√† pr√©sente, mise √† jour du style`);
    window.map.setPaintProperty(fillLayerId, 'fill-color', fillPaintObj['fill-color']);
    window.map.setPaintProperty(fillLayerId, 'fill-opacity', fillPaintObj['fill-opacity']);
  } else {
    console.log(`Couche ${fillLayerId} absente, ajout en cours...`);
    try {
      window.map.addLayer({
        id: fillLayerId,
        type: 'fill',
        source: layerId,
        'source-layer': config.sourceLayer,
        minzoom: config.minzoom,
        maxzoom: config.maxzoom,
        paint: fillPaintObj
      }, 'settlement-subdivision-label');
      console.log(`Couche ${fillLayerId} ajout√©e`);
    } catch (error) {
      console.error(`Erreur lors de l‚Äôajout de ${fillLayerId}:`, error);
    }
  }

  const outlineLayerId = layerId + '-outline';
  if (window.map.getLayer(outlineLayerId)) {
    console.log(`Couche ${outlineLayerId} d√©j√† pr√©sente`);
    // Pas besoin de mise √† jour ici, les propri√©t√©s sont statiques
  } else {
    console.log(`Couche ${outlineLayerId} absente, ajout en cours...`);
    try {
      window.map.addLayer({
        id: outlineLayerId,
        type: 'line',
        source: layerId,
        'source-layer': config.sourceLayer,
        minzoom: config.minzoom,
        maxzoom: config.maxzoom,
        paint: {
          'line-color': '#FFFFFF',
          'line-width': 1,
          'line-opacity': 0.8,
          'line-blur': 0
        },
        layout: {
          'line-join': 'round',
          'line-cap': 'round'
        }
      }, 'settlement-subdivision-label');
      console.log(`Couche ${outlineLayerId} ajout√©e`);
    } catch (error) {
      console.error(`Erreur lors de l‚Äôajout de ${outlineLayerId}:`, error);
    }
  }
/* ----------  Ajout UNIQUE des couches de s√©lection  ---------- */
if (layerId === 'iris') {
  /* Remplissage du polygone s√©lectionn√© */
  if (!window.map.getLayer('iris-selected-fill')) {
    window.map.addLayer({
      id: 'iris-selected-fill',
      type: 'fill',
      source: 'iris',
      'source-layer': layerConfigs['iris'].sourceLayer,
      paint: {
        'fill-color': 'rgba(255,215,0,0.35)', // jaune or translucide
        'fill-opacity': 0.8
      },
      filter: ['==', ['get', 'CODE_IRIS'], ''], // vide au d√©part
      layout: {
        'visibility': 'none' // Masqu√© par d√©faut
      }
    }, 'iris-labels'); // Placer sous les √©tiquettes pour √©viter de masquer les labels
    console.log('‚ûï Couche iris-selected-fill ajout√©e');
  }

  /* Bordure du polygone s√©lectionn√© */
  if (!window.map.getLayer('iris-selected-outline')) {
    window.map.addLayer({
      id: 'iris-selected-outline',
      type: 'line',
      source: 'iris',
      'source-layer': layerConfigs['iris'].sourceLayer,
      paint: {
        'line-color': '#FFD700', // jaune or
        'line-width': 3,
        'line-opacity': 1
      },
      filter: ['==', ['get', 'CODE_IRIS'], ''], // vide au d√©part
      layout: {
        'visibility': 'none' // Masqu√© par d√©faut
      }
    }, 'iris-labels'); // Placer sous les √©tiquettes
    console.log('‚ûï Couche iris-selected-outline ajout√©e');
  }
}
/* ----------  Fin ajout s√©lection  ---------- */


if (config.labels?.enabled) {
  const labelLayerId = `${layerId}-labels`;
  let textFieldExpr;

// G√©rer les valeurs nulles dans les labels avec "NA"
    const valueExpr = ['coalesce', ['get', config.labels.field], 'NA']; // Remplace null par "NA"

  // D√©terminer le format √† appliquer
switch (config.labels.labelFormat) {
      case 'percent-1': // Ex. "2,9 %"
        textFieldExpr = [
          'case',
          ['==', ['get', config.labels.field], null], 'NA',
          ['concat', ['number-format', ['*', ['to-number', valueExpr], 100], { 'min-fraction-digits': 1, 'max-fraction-digits': 1 }], ' %']
        ];
        break;
      case 'percent-0': // Ex. "3 %"
        textFieldExpr = [
          'case',
          ['==', ['get', config.labels.field], null], 'NA',
          ['concat', ['round', ['*', ['to-number', valueExpr], 100]], ' %']
        ];
        break;
      case 'currency-euro': // Ex. "45 098 ‚Ç¨"
        textFieldExpr = [
          'case',
          ['==', ['get', config.labels.field], null], 'NA',
          ['concat', ['number-format', ['to-number', valueExpr], { 'locale': 'fr', 'min-fraction-digits': 0, 'max-fraction-digits': 0 }], ' ‚Ç¨']
        ];
        break;
      case 'number-1': // Ex. "13,7"
        textFieldExpr = [
          'case',
          ['==', ['get', config.labels.field], null], 'NA',
          ['number-format', ['to-number', valueExpr], { 'min-fraction-digits': 1, 'max-fraction-digits': 1 }]
        ];
        break;
      default: // Valeur brute
        textFieldExpr = valueExpr;
    }

    if (window.map.getLayer(labelLayerId)) {
      console.log(`Couche ${labelLayerId} d√©j√† pr√©sente, mise √† jour du text-field`);
      window.map.setLayoutProperty(labelLayerId, 'text-field', textFieldExpr);
    } else {
      console.log(`Couche ${labelLayerId} absente, ajout en cours...`);
      try {
        window.map.addLayer({
          id: labelLayerId,
          type: 'symbol',
          source: layerId,
          'source-layer': config.sourceLayer,
          minzoom: config.labels.minzoom || 0,
          maxzoom: config.maxzoom || 22,
          layout: {
            'text-field': textFieldExpr,
            'text-size': config.labels.textSize || 12,
            'text-anchor': 'center'
          },
          paint: {
            'text-color': config.labels.color || '#000',
            'text-halo-color': config.labels.haloColor || '#fff',
            'text-halo-width': config.labels.haloWidth || 1
          }
        }, 'settlement-subdivision-label');
        console.log(`Couche ${labelLayerId} ajout√©e`);
      } catch (error) {
        console.error(`Erreur lors de l‚Äôajout de ${labelLayerId}:`, error);
      }
    }
  }

  if (config.clickable && !window.map.listens('click', fillLayerId)) {
    window.map.on('click', fillLayerId, e => handleLayerClick(e, layerId));
    window.map.on('mouseenter', fillLayerId, () => window.map.getCanvas().style.cursor = 'pointer');
    window.map.on('mouseleave', fillLayerId, () => window.map.getCanvas().style.cursor = '');
  }
}


    let lastClickedFeatureId = null;

    function handleLayerClick(e, layerId) {
      const config = layerConfigs[layerId];
      if (!config || !e.features[0]) return;

      const feature = e.features[0];
      const codeIris = feature.properties[config.idField];
      window.selectGeometry(layerId, codeIris);  // <--- On r√©utilise la fonction commune
    }

window.updateMapLayers = function(layerId) {
  if (!window.map) return;

  console.log(`Mise √† jour de ${layerId}`);

  addLayer(layerId);

  const config = layerConfigs[layerId];
  if (window.map.getLayer(layerId + '-fill')) {
    window.map.setLayoutProperty(layerId + '-fill', 'visibility', 'visible');
    console.log(`${layerId}-fill rendu visible`);
  } else {
    console.error(`${layerId}-fill n‚Äôa pas √©t√© ajout√©`);
  }
  if (window.map.getLayer(layerId + '-outline')) {
    window.map.setLayoutProperty(layerId + '-outline', 'visibility', 'visible');
    console.log(`${layerId}-outline rendu visible`);
  } else {
    console.error(`${layerId}-outline n‚Äôa pas √©t√© ajout√©`);
  }
  if (config?.labels?.enabled && window.map.getLayer(layerId + '-labels')) {
    window.map.setLayoutProperty(layerId + '-labels', 'visibility', labelsVisible ? 'visible' : 'none');
    console.log(`${layerId}-labels mis √† ${labelsVisible ? 'visible' : 'none'}`);
  } else if (config?.labels?.enabled) {
    console.error(`${layerId}-labels n‚Äôa pas √©t√© ajout√©`);
  }

  window.map.triggerRepaint();
  console.log(`Rendu forc√© pour ${layerId}`);
};

    // Gestion des couches choropleths
  /****************************************************
     * showChoroplethLayer(layerId)
     * => exclusif : on masque l'ancien + on affiche le nouveau
     ****************************************************/

let labelsVisible = true; // Par d√©faut, les labels sont visibles

window.showChoroplethLayer = function(layerId) {
  if (!window.map) {
    console.log(`Carte non initialis√©e pour ${layerId}, attente...`);
    setTimeout(() => window.showChoroplethLayer(layerId), 300);
    return;
  }

  const config = layerConfigs[layerId];
  if (!config || !config.isChoropleth) {
    console.warn(`${layerId} n‚Äôest pas un choropl√®the`);
    return;
  }

  console.log(`[showChoroplethLayer] On veut afficher : ${layerId}`);

  Object.keys(layerConfigs).forEach(other => {
    const c = layerConfigs[other];
    if (c.isChoropleth && other !== layerId) {
      if (window.map.getLayer(other + '-fill')) {
        window.map.setLayoutProperty(other + '-fill', 'visibility', 'none');
        console.log(`${other}-fill masqu√©`);
      }
      if (window.map.getLayer(other + '-outline')) {
        window.map.setLayoutProperty(other + '-outline', 'visibility', 'none');
        console.log(`${other}-outline masqu√©`);
      }
      if (c.labels?.enabled && window.map.getLayer(other + '-labels')) {
        window.map.setLayoutProperty(other + '-labels', 'visibility', 'none');
        console.log(`${other}-labels masqu√©`);
      }
    }
  });

  window.updateMapLayers(layerId);
  if (config.labels?.enabled && window.map.getLayer(layerId + '-labels')) {
    window.map.setLayoutProperty(layerId + '-labels', 'visibility', labelsVisible ? 'visible' : 'none');
    console.log(`${layerId}-labels mis √† ${labelsVisible ? 'visible' : 'none'}`);
  }

  currentChoropleth = layerId;
  window.map.triggerRepaint();
  console.log(`Affichage de ${layerId} termin√©`);
};

window.toggleLabels = function(show) {
  if (!window.map) {
    console.log("Carte non initialis√©e, r√©essai dans 300ms");
    setTimeout(() => window.toggleLabels(show), 300);
    return;
  }

  // V√©rifie si l‚Äô√©tat change vraiment pour √©viter les appels redondants
  if (labelsVisible === show) {
    console.log(`√âtat des labels d√©j√† √† ${show ? 'visible' : 'none'}, pas de changement`);
    return;
  }

  labelsVisible = show; // Mettre √† jour l‚Äô√©tat global
  console.log(`Toggle labels : ${show ? 'visible' : 'none'}`);
  const visibility = show ? 'visible' : 'none';

  Object.keys(layerConfigs).forEach(layerId => {
    const config = layerConfigs[layerId];
    if (config.labels?.enabled && window.map.getLayer(layerId + '-labels')) {
      window.map.setLayoutProperty(layerId + '-labels', 'visibility', visibility);
      console.log(`Labels de ${layerId} mis √† ${visibility}`);
    }
  });

  window.map.triggerRepaint();
};


    /****************************************************
     * hideChoropleth()
     * => masque le choropleth actif
     ****************************************************/
    window.hideChoropleth = function() { // ****CHANGEMENT****
      if (!currentChoropleth) return;
      const oldConfig = layerConfigs[currentChoropleth];
      // fill
      if (window.map.getLayer(currentChoropleth + '-fill')) {
        window.map.setLayoutProperty(currentChoropleth + '-fill', 'visibility', 'none');
      }
      // outline
      if (window.map.getLayer(currentChoropleth + '-outline')) {
        window.map.setLayoutProperty(currentChoropleth + '-outline', 'visibility', 'none');
      }
      // labels
      if (oldConfig?.labels?.enabled && window.map.getLayer(currentChoropleth + '-labels')) {
        window.map.setLayoutProperty(currentChoropleth + '-labels', 'visibility', 'none');
      }
      currentChoropleth = null;
    };

window.showLayerAfterResize = function(loadFunctionName, ...args) {
  if (!window.map) {
    console.log("Carte non initialis√©e, r√©essai dans 300ms");
    setTimeout(() => window.showLayerAfterResize(loadFunctionName, ...args), 300);
    return;
  }

  console.log(`D√©but de showLayerAfterResize pour ${loadFunctionName} avec args:`, args);

  window.map.resize();
  setTimeout(() => {
    if (!window.map.isStyleLoaded()) {
      console.log("Style non charg√©, attente...");
      window.map.once('render', () => {
        console.log("Carte rendue apr√®s resize");
        executeLoadFunction(loadFunctionName, args);
      });
    } else {
      console.log("Style d√©j√† charg√©, ex√©cution imm√©diate");
      executeLoadFunction(loadFunctionName, args);
    }
  }, 200);

  function executeLoadFunction(fnName, fnArgs) {
    if (typeof window[fnName] === 'function') {
      window[fnName](...fnArgs);
      window.map.triggerRepaint();
      console.log(`Ex√©cution de ${fnName} termin√©e, rendu forc√©`);
    } else {
      console.error(`La fonction ${fnName} n‚Äôexiste pas`);
    }
  }
};

    // Fonction pour param√©trer le toggle des labels des cartes
window.toggleLabels = function(show) {
  if (!window.map) {
    console.log("Carte non initialis√©e, r√©essai dans 300ms");
    setTimeout(() => window.toggleLabels(show), 300);
    return;
  }

  labelsVisible = show; // Mettre √† jour l‚Äô√©tat global
  console.log(`Toggle labels : ${show ? 'visible' : 'none'}`);
  const visibility = show ? 'visible' : 'none';

  Object.keys(layerConfigs).forEach(layerId => {
    const config = layerConfigs[layerId];
    if (config.labels?.enabled && window.map.getLayer(layerId + '-labels')) {
      window.map.setLayoutProperty(layerId + '-labels', 'visibility', visibility);
      console.log(`Labels de ${layerId} mis √† ${visibility}`);
    }
  });

  window.map.triggerRepaint();
};

/* --------  Zoom / fitBounds sur une liste de codes IRIS (Version avec ajout de couche) -------- */
window.zoomToIris = function(codes, focusCode = null) {
  console.log("‚û°Ô∏è zoomToIris called with:", codes);

  if (!codes || !Array.isArray(codes) || codes.length === 0) {
    console.warn("üõë No valid codes provided");
    return;
  }

  if (!window.map) {
    console.warn("üõë Map not initialized, retrying in 300ms...");
    setTimeout(() => window.zoomToIris(codes), 300);
    return;
  }

// Dans le cadre de la s√©lection des IRIS
window.lastIrisList = codes.slice();   // copie d√©fensive

  if (!window.map.loaded()) {
    console.warn("üõë Map not loaded, waiting for 'load' event...");
    window.map.once('load', () => {
      console.log("‚úÖ Map loaded, retrying zoomToIris");
      window.zoomToIris(codes);
    });
    return;
  }

  // 0Ô∏è‚É£ Cacher imm√©diatement les couches collectivit√©s et radius
  ['collectivites-fill', 'collectivites-outline', 'radius-fill', 'radius-outline'].forEach(id => {
    if (window.map.getLayer(id)) {
      window.map.setLayoutProperty(id, 'visibility', 'none');
      console.log(`‚úÖ Hid layer ${id}`);
    }
  });

  // 1Ô∏è‚É£ Nettoyer les couches temporaires IRIS pr√©c√©dentes
  ['iris-temp', 'iris-temp-outline'].forEach(layerId => {
    if (window.map.getLayer(layerId)) {
      window.map.removeLayer(layerId);
      console.log(`‚úÖ Removed previous ${layerId} layer`);
    }
  });

  if (!window.map.getSource('iris')) {
    console.log("‚ûï Adding IRIS source...");
    try {
      window.map.addSource('iris', layerConfigs['iris'].source);
    } catch (error) {
      console.error("üõë Error adding IRIS source:", error);
      return;
    }
  }

  let targetLayerId = 'iris-fill';
  if (!window.map.getLayer('iris-fill')) {
    console.log("‚ûï Adding temporary IRIS layers 'iris-temp' and 'iris-temp-outline'...");
    try {
      // Ajouter la couche de remplissage
      window.map.addLayer({
        id: 'iris-temp',
        type: 'fill',
        source: 'iris',
        'source-layer': layerConfigs['iris'].sourceLayer,
        paint: {
          'fill-color': '#8A2BE2',
          'fill-opacity': 0.25
        },
        filter: ['match', ['get', 'CODE_IRIS'], codes, true, false]
      }, 'settlement-subdivision-label');
      registerIrisClickListeners();


      // Ajouter une couche de bordure avec line-width: 2
      window.map.addLayer({
        id: 'iris-temp-outline',
        type: 'line',
        source: 'iris',
        'source-layer': layerConfigs['iris'].sourceLayer,
        paint: {
          'line-color': '#8A2BE2',
          'line-width': 2,
          'line-opacity': 1
        },
        filter: ['match', ['get', 'CODE_IRIS'], codes, true, false]
      }, 'settlement-subdivision-label');

      targetLayerId = 'iris-temp';
    } catch (error) {
      console.error("üõë Error adding temporary IRIS layers:", error);
      return;
    }
  } else {
    console.log("üîç Using existing IRIS layers...");
    ['iris-fill', 'iris-outline', 'iris-labels'].forEach(layerId => {
      if (window.map.getLayer(layerId)) {
        window.map.setLayoutProperty(layerId, 'visibility', 'visible');
        if (layerId === 'iris-outline') {
          window.map.setPaintProperty(layerId, 'line-width', 2);
          console.log("‚úÖ Updated iris-outline line-width to 2");
        }
      }
    });
    registerIrisClickListeners();   // ‚Üê nouveau
  }

  window.map.once('idle', () => {
    console.log("‚úÖ Layer rendered, proceeding with filter...");

    const allFeats = window.map.querySourceFeatures('iris', {
      sourceLayer: layerConfigs['iris'].sourceLayer
    });

    if (allFeats.length === 0) {
      console.warn("üõë Source IRIS encore vide ‚Äî probable souci de style ou de filtre. On s‚Äôarr√™te ici sans modifier le zoom.");
      return;
    }

    applyFilter(allFeats);

    function applyFilter(allFeatures) {
      console.log("üéØ Applying filter with", allFeatures.length, "features");

      const firstFeat = allFeatures[0];
      const codeField = Object.keys(firstFeat.properties).find(f => f === 'CODE_IRIS' || codes.includes(String(firstFeat.properties[f])));
      if (!codeField) {
        console.error("‚ùå IRIS code field not found");
        console.log("üîç Available properties:", Object.keys(firstFeat.properties));
        return;
      }

      const matchingFeatures = allFeatures.filter(f =>
        codes.includes(String(f.properties[codeField]))
      );

      if (matchingFeatures.length === 0) {
        console.warn("üõë No matching features found for codes:", codes);
        const sampleCodes = allFeatures.slice(0, 5).map(f => f.properties[codeField]);
        console.log("üîç Sample codes in data:", sampleCodes);
        return;
      }

      const filter = ['match', ['get', codeField], codes, true, false];
      window.map.setFilter(targetLayerId, filter);
      if (window.map.getLayer('iris-outline')) {
        window.map.setFilter('iris-outline', filter);
        window.map.setPaintProperty('iris-outline', 'line-width', 2);
      }
      if (window.map.getLayer('iris-labels')) {
        window.map.setFilter('iris-labels', filter);
      }

      window.hideAllLayers();
      window.map.setLayoutProperty(targetLayerId, 'visibility', 'visible');
      if (window.map.getLayer('iris-outline')) {
        window.map.setLayoutProperty('iris-outline', 'visibility', 'visible');
      }
      if (window.map.getLayer('iris-labels')) {
        window.map.setLayoutProperty('iris-labels', 'visibility', 'visible');
      }

      console.log("‚úÖ Filter applied successfully, keeping current map viewport");
      applySelectionPaint(codes, focusCode);
    }
  });
};

window.resetRecherche = function() {
  console.log("‚û°Ô∏è resetRecherche called");

  if (!window.map) {
    console.warn("‚ö†Ô∏è Map not initialized, retrying in 300ms...");
    setTimeout(window.resetRecherche, 300);
    return;
  }

  if (!window.map.loaded()) {
    console.warn("üõë Map not loaded, waiting for 'load' event...");
    window.map.once('load', () => {
      console.log("‚úÖ Map loaded, retrying resetRecherche");
      window.resetRecherche();
    });
    return;
  }

  // 1. Supprimer les couches temporaires IRIS
  ['iris-temp', 'iris-temp-outline'].forEach(layerId => {
    if (window.map.getLayer(layerId)) {
      window.map.removeLayer(layerId);
      console.log(`‚úÖ Removed ${layerId} layer`);
    }
  });

  // 2. Masquer et r√©initialiser les filtres des couches IRIS existantes
  ['iris-fill', 'iris-outline', 'iris-labels'].forEach(layerId => {
    if (window.map.getLayer(layerId)) {
      window.map.setLayoutProperty(layerId, 'visibility', 'none');
      window.map.setFilter(layerId, null);
      console.log(`‚úÖ Hid and reset filter for ${layerId}`);
      if (layerId === 'iris-outline') {
        window.map.setPaintProperty(layerId, 'line-width', 2);
        console.log("‚úÖ Reset iris-outline line-width to 2");
      }
    }
  });

  // 3. Restaurer les donn√©es en fonction de la m√©thode utilis√©e
  // Initialiser window.radiusData si n√©cessaire
  if (!window.radiusData || !window.radiusData.features) {
    window.radiusData = { type: 'FeatureCollection', features: [] };
    console.log("‚úÖ Initialized empty radiusData");
  }

  if (window.radiusData.features.length > 0 && window.radiusCenter && typeof window.radiusKm === 'number' && window.radiusKm > 0) {
    // M√©thode 2 : Restaurer le cercle
    console.log("üîÑ Restoring radius (method 2)");
    if (!window.map.getSource('radius')) {
      console.log("‚ûï Recreating radius source...");
      try {
        window.map.addSource('radius', {
          type: 'geojson',
          data: window.radiusData
        });
      } catch (error) {
        console.error("üî¥ Error recreating radius source:", error);
        return;
      }
    } else {
      console.log("üîç Updating radius source data...");
      window.map.getSource('radius').setData(window.radiusData);
    }

    if (!window.map.getLayer('radius-fill')) {
      console.log("‚ûï Adding radius-fill layer...");
      try {
        window.map.addLayer({
          id: 'radius-fill',
          type: 'fill',
          source: 'radius',
          paint: { 'fill-color': '#8A2BE2', 'fill-opacity': 0.2 }
        });
      } catch (error) {
        console.error("üî¥ Error adding radius-fill layer:", error);
      }
    } else {
      window.map.setLayoutProperty('radius-fill', 'visibility', 'visible');
      console.log("‚úÖ Made radius-fill visible");
    }

    if (!window.map.getLayer('radius-outline')) {
      console.log("‚ûï Adding radius-outline layer...");
      try {
        window.map.addLayer({
          id: 'radius-outline',
          type: 'line',
          source: 'radius',
          paint: { 'line-color': '#8A2BE2', 'line-width': 2 }
        });
      } catch (error) {
        console.error("üî¥ Error adding radius-outline layer:", error);
      }
    } else {
      window.map.setLayoutProperty('radius-outline', 'visibility', 'visible');
      console.log("‚úÖ Made radius-outline visible");
    }

    // Restaurer le marqueur
    if (!window.radiusMarker && window.radiusCenter) {
      console.log("‚ûï Recreating radius marker...");
      try {
        window.radiusMarker = new mapboxgl.Marker({ color: '#8A2BE2' })
          .setLngLat([window.radiusCenter.lon, window.radiusCenter.lat])
          .addTo(window.map);
      } catch (error) {
        console.error("üî¥ Error recreating radius marker:", error);
      }
    }

    console.log("‚úÖ Radius restored, keeping current map viewport");
  } else if (window.collectivitesData?.features?.length > 0) {
    // M√©thode 1 : Restaurer les collectivit√©s
    console.log("üîÑ Restoring collectivites (method 1)");
    if (!window.map.getSource('collectivites')) {
      console.log("‚ûï Recreating collectivites source...");
      try {
        window.map.addSource('collectivites', {
          type: 'geojson',
          data: window.collectivitesData
        });
      } catch (error) {
        console.error("üî¥ Error recreating collectivites source:", error);
        return;
      }
    } else {
      console.log("üîç Updating collectivites source data...");
      window.map.getSource('collectivites').setData(window.collectivitesData);
    }

    if (!window.map.getLayer('collectivites-fill')) {
      console.log("‚ûï Adding collectivites-fill layer...");
      try {
        window.map.addLayer({
          id: 'collectivites-fill',
          type: 'fill',
          source: 'collectivites',
          paint: { 'fill-color': '#8A2BE2', 'fill-opacity': 0.25 }
        });
      } catch (error) {
        console.error("üî¥ Error adding collectivites-fill layer:", error);
      }
    } else {
      window.map.setLayoutProperty('collectivites-fill', 'visibility', 'visible');
      console.log("‚úÖ Made collectivites-fill visible");
    }

    if (!window.map.getLayer('collectivites-outline')) {
      console.log("‚ûï Adding collectivites-outline layer...");
      try {
        window.map.addLayer({
          id: 'collectivites-outline',
          type: 'line',
          source: 'collectivites',
          paint: { 'line-color': '#8A2BE2', 'line-width': 2 }
        });
      } catch (error) {
        console.error("üî¥ Error adding collectivites-outline layer:", error);
      }
    } else {
      window.map.setLayoutProperty('collectivites-outline', 'visibility', 'visible');
      console.log("‚úÖ Made collectivites-outline visible");
    }

    console.log("‚úÖ Collectivit√©s restored, keeping current map viewport");
  } else {
    console.warn("‚ö†Ô∏è No data available to restore (neither collectivites nor radius)");
  }
};

  // 1) R√©initialiser l‚Äô√©ventuel feature cliqu√©
    // 2) Appliquer setFeatureState
    // 3) Appeler la fonction Bubble
window.selectGeometry = function(layerId, codeIris) {
  const config = layerConfigs[layerId];
  if (!window.map || !config) {
    console.error("üõë Map or config not available for selectGeometry");
    return;
  }

  console.log(`‚úÖ Selecting IRIS with CODE_IRIS: ${codeIris}`);

  // 1. R√©initialiser les filtres des couches de s√©lection
  ['iris-selected-fill', 'iris-selected-outline'].forEach(layerId => {
    if (window.map.getLayer(layerId)) {
      window.map.setFilter(layerId, ['==', ['get', 'CODE_IRIS'], '']); // Masquer d'abord
    }
  });

  // 2. Appliquer le filtre pour l'IRIS cliqu√©
  ['iris-selected-fill', 'iris-selected-outline'].forEach(layerId => {
    if (window.map.getLayer(layerId)) {
      window.map.setFilter(layerId, ['==', ['get', 'CODE_IRIS'], codeIris]);
      window.map.setLayoutProperty(layerId, 'visibility', 'visible');
      console.log(`‚úÖ Set filter and visibility for ${layerId}`);
    } else {
      console.warn(`üõë Layer ${layerId} not found`);
    }
  });

  // 3. Remonter les couches de s√©lection au-dessus des autres
  if (window.map.getLayer('iris-selected-fill')) window.map.moveLayer('iris-selected-fill', 'iris-labels');
  if (window.map.getLayer('iris-selected-outline')) window.map.moveLayer('iris-selected-outline', 'iris-labels');

  // 4. Forcer le rendu
  window.map.triggerRepaint();
  console.log("‚úÖ Triggered repaint for selection");

  // 5. Envoyer l‚Äôinfo √† Bubble
  if (typeof bubble_fn_mapClicked === 'function') {
    bubble_fn_mapClicked({ output1: layerId, output2: codeIris });
    console.log(`‚úÖ Called bubble_fn_mapClicked with layerId: ${layerId}, codeIris: ${codeIris}`);
  }

  // 6. Supprimer l'appel √† applySelectionPaint pour √©viter les conflits
  // if (layerId === 'iris') {
  //   applySelectionPaint(window.lastIrisList || [], codeIris);
  // }
};

window.zoomToIrisQueued = function(codes, focusCode = null){
  if (!window.map || !window.map.loaded()) {
    console.log("Map pas pr√™te, attente pour zoomToIris...");
    setTimeout(() => window.zoomToIrisQueued(codes, focusCode), 300);
  } else {
    window.zoomToIris(codes, focusCode);
  }
};

    // Fonction qui va permettre la s√©lection des IRIS
function applySelectionPaint(allCodes, focusCode){
  // 1.  couleur de fond pour TOUS les IRIS affich√©s
  const baseFilter = ['match', ['get', 'CODE_IRIS'], allCodes, true, false];
  window.map.setFilter('iris-fill'        , baseFilter);
  window.map.setFilter('iris-outline'     , baseFilter);
  if (window.map.getLayer('iris-temp')) {          // cas o√π on utilise la couche temporaire
    window.map.setFilter('iris-temp'      , baseFilter);
    window.map.setFilter('iris-temp-outline', baseFilter);
  }

  // 2.  ‚Äúfocus‚Äù √©ventuel ‚ûú feature-state { clicked:true }
  //     on commence par tout remettre √† false
  const feats = window.map.querySourceFeatures('iris', {
      sourceLayer: layerConfigs['iris'].sourceLayer,
      filter: baseFilter
  });
  feats.forEach(f =>
    window.map.setFeatureState(
      { source:'iris', sourceLayer:layerConfigs['iris'].sourceLayer, id:f.id },
      { clicked:false })
  );

  if (focusCode){
    const f = feats.find(ff => ff.properties.CODE_IRIS === focusCode);
    if (f){
      window.map.setFeatureState(
        { source:'iris', sourceLayer:layerConfigs['iris'].sourceLayer, id:f.id },
        { clicked:true });
    }
  }
}



    // D√©marrer l‚Äôinitialisation
    setTimeout(initializeMap, 100);
  </script>
</body>
</html>