<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Carte Mapbox avec s√©lection des communes et d√©partements</title>
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet">
  <script defer src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
  <script defer src="https://api.mapbox.com/search-js/v1.0.0/web.js"></script>
  <!-- Turf pour g√©n√©rer le cercle du second mode de recherche -->
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>

  <style>
    .my-map-container {
      margin: 0;
      padding: 0;
      font-family: "Inter", sans-serif;
      position: relative;
      width: 100%;
      height: 100%;
    }
    #map {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 100%;
    }
    .legend {
      position: absolute;
      bottom: 20px;
      right: 20px;
      background: rgba(255, 255, 255, 0.9);
      padding: 10px;
      border-radius: 4px;
      font-size: 12px;
    }
    .legend-item {
      display: flex;
      align-items: center;
      margin: 5px 0;
    }
    .legend-color {
      width: 20px;
      height: 20px;
      margin-right: 5px;
    }
    #search-box-container {
      position: absolute;
      top: 16px;
      left: 50%;
      transform: translateX(-50%);
      width: 300px;
      zIndex: 1;
    }

  </style>
</head>
<body>
  <div class="my-map-container">
    <div id="map"></div>
    <div id="search-box-container"></div>
  </div>

  <script>
    /****************************************************
     * Code principal JavaScript pour la carte Mapbox
     ****************************************************/
    window.map = null; // Variable globale unique
    window.collectivitesData = { type: 'FeatureCollection', features: [] }; // Stocke les donn√©es GeoJSON des collectivit√©s
    window.radiusData = { type: 'FeatureCollection', features: [] }; // Stocke le GeoJSON du cercle    let currentLayerId = null;
    let currentChoropleth = null; 

    window.layerConfigs = {
      iris: {
        source: { type: 'vector', url: 'mapbox://hadrienleger.ak5sb828' },
        sourceLayer: 'iris-ign-petite-etendue-wgs84-7y17me',
basePaint: {
  'fill-color': '#8A2BE2',  // Couleur fixe au lieu de feature-state
  'fill-opacity': 0.25
},
        idField: 'CODE_IRIS',
        clickable: true,
        useFeatureStateClicked: true,
        isChoropleth: false,
        labels: { enabled: true, field: 'NOM_IRIS', textSize: 12, color: '#FFF', haloColor: '#000', haloWidth: 1 },
        minzoom: 8,
        maxzoom: 22
      },
      txcouv_creches: {
        source: { type: 'vector', url: 'mapbox://hadrienleger.5ab8lona' },
        sourceLayer: 'txcouv_creches_2022-4v4l8g',
        isChoropleth: true,
        property: 'txcouv_eaje_com',
        breaks: [17.4, 27.1, 37.8, 53.2], // 4 seuils pour 5 intervalles
        colors: ['#D2E3F9', '#9FC2F4', '#5C9CED', '#2F6BC7', '#0F3B66'], // 5 couleurs
        nullColor: '#d3d3d3', // Gris clair pour les valeurs nulles
        opacity: 0.8,
        clickable: false,
        labels: {
          enabled: true,
          field: 'txcouv_eaje_com',
          textSize: 12,
          color: '#333',
          haloColor: 'rgba(255,255,255,0.8)',
          haloWidth: 2,
          labelFormat: 'number-1'
        },
        minzoom: 8,
        maxzoom: 22
      },
      txcouv_assmats: {
        source: { type: 'vector', url: 'mapbox://hadrienleger.5ab8lona' },
        sourceLayer: 'txcouv_creches_2022-4v4l8g',
        isChoropleth: true,
        property: 'txcouv_am_ind_com',
        breaks: [17.4, 27.1, 37.8, 53.2], // 4 seuils pour 5 intervalles
        colors: ['#D2E3F9', '#9FC2F4', '#5C9CED', '#2F6BC7', '#0F3B66'], // 5 couleurs
        nullColor: '#d3d3d3', // Gris clair pour les valeurs nulles
        opacity: 0.8,
        clickable: false,
        labels: {
          enabled: true,
          field: 'txcouv_am_ind_com',
          textSize: 12,
          color: '#333',
          haloColor: 'rgba(255,255,255,0.8)',
          haloWidth: 2,
          labelFormat: 'number-1'
        },
        minzoom: 8,
        maxzoom: 22
      },
      txcouv_tousmodes: {
        source: { type: 'vector', url: 'mapbox://hadrienleger.5ab8lona' },
        sourceLayer: 'txcouv_creches_2022-4v4l8g',
        isChoropleth: true,
        property: 'txcouv_com',
        breaks: [17.4, 27.1, 37.8, 53.2], // 4 seuils pour 5 intervalles
        colors: ['#D2E3F9', '#9FC2F4', '#5C9CED', '#2F6BC7', '#0F3B66'], // 5 couleurs
        nullColor: '#d3d3d3', // Gris clair pour les valeurs nulles
        opacity: 0.8,
        clickable: false,
        labels: {
          enabled: true,
          field: 'txcouv_com',
          textSize: 12,
          color: '#333',
          haloColor: 'rgba(255,255,255,0.8)',
          haloWidth: 2,
          labelFormat: 'number-1'
        },
        minzoom: 8,
        maxzoom: 22
      },
      eaje_points: {
        source: { 
          type: 'vector', 
          url: 'mapbox://hadrienleger.0xtn83cx'
        },
        sourceLayer: 'bpe2024_eaje-22sm96',
        isPoints: true,
        paint: {
          'circle-radius': ['interpolate', ['linear'], ['zoom'], 11, 4, 15, 8],
          'circle-color': '#4CAF50',
          'circle-stroke-color': '#ffffff',
          'circle-stroke-width': 2,
          'circle-opacity': 0.8
        },
        clickable: true,
        popup: {
          fields: ['nom', 'adresse', 'accueil', 'capacite'],
          // Mapping pour affichage √©l√©gant
          fieldLabels: {
            'nom': 'Nom',
            'adresse': 'Adresse',
            'accueil': 'Type d\'√©tablissement',
            'capacite': 'Nombre de places'
          }
        },
        minzoom: 10,
        maxzoom: 22
      },
      points_ecoles: {
        source: { 
          type: 'vector', 
          url: 'mapbox://hadrienleger.3jgy0bed'
        },
        sourceLayer: 'points_ecoles-3q4w5i',
        isPoints: true,
        paint: {
          'circle-radius': ['interpolate', ['linear'], ['zoom'], 11, 4, 15, 8],
          'circle-color': '#4CAF50',
          'circle-stroke-color': '#ffffff',
          'circle-stroke-width': 2,
          'circle-opacity': 0.8
        },
        clickable: true,
        popup: {
          fields: ['nom_ecole', 'secteur', 'adresse_ecole', 'ips', 'etat', 'code_rne'],
          // Mapping pour affichage √©l√©gant
          fieldLabels: {
            'nom_ecole': "Nom de l'√©cole",
            'secteur': 'Public/priv√©',
            'adresse_ecole': 'Adresse',
            'ips': 'IPS',
            'etat': 'Ouvert/Ferm√©',
            'code_rne': 'Code RNE'
          }
        },
        minzoom: 10,
        maxzoom: 22
      },
      top_ecole_300m: {
        source: { 
          type: 'vector', 
          url: 'mapbox://hadrienleger.cdwvsbui'
        },
        sourceLayer: 'iris_top_ecole_300m-8y6jjr',
        isChoropleth: true,
        property: 'ips_pu',  // Valeur initiale par d√©faut
        breaks: [86, 100, 112, 126.8],
        colors: ['#D2E3F9', '#9FC2F4', '#5C9CED', '#2F6BC7', '#0F3B66'], // 5 couleurs
        nullColor: '#d3d3d3', // Gris clair pour les valeurs nulles
        opacity: 0.8,
        clickable: true,
        popup: {
          fields: ['nom_iris', 'nom_pu', 'ips_pu', 'adresse_pu', 'nom_pr', 'ips_pr', 'adresse_pr'],
          // Mapping pour affichage √©l√©gant
          fieldLabels: {
            'nom_iris': 'Nom du quartier',
            'nom_pu': 'Meilleure √©cole publique',
            'ips_pu': 'IPS',
            'adresse_pu': 'Adresse',
            'nom_pr': 'Meilleure √©cole priv√©e',
            'ips_pr': 'IPS',
            'adresse_pr': 'Adresse'
          }
        },
        labels: {
          enabled: false,
          field: 'ips_pu',  // Valeur initiale par d√©faut
          textSize: 12,
          color: '#333',
          haloColor: 'rgba(255,255,255,0.8)',
          haloWidth: 2,
          labelFormat: 'number-1'
        },
         minzoom: 8,
         maxzoom: 22
            },
top_ecole_600m: {
  source: { 
    type: 'vector', 
    url: 'mapbox://hadrienleger.dqk8grr8'  // √Ä remplacer
  },
  sourceLayer: 'top_ecole_600m-7qckte',  // √Ä remplacer
  isChoropleth: true,
  property: 'ips_pu',
  breaks: [86, 100, 112, 126.8],
  colors: ['#D2E3F9', '#9FC2F4', '#5C9CED', '#2F6BC7', '#0F3B66'],
  nullColor: '#d3d3d3',
  opacity: 0.8,
  clickable: true,
  popup: {
    fields: ['nom_iris', 'nom_pu', 'ips_pu', 'adresse_pu', 'nom_pr', 'ips_pr', 'adresse_pr'],
    fieldLabels: {
      'nom_iris': 'Nom du quartier',
      'nom_pu': 'Meilleure √©cole publique',
      'ips_pu': 'IPS',
      'adresse_pu': 'Adresse',
      'nom_pr': 'Meilleure √©cole priv√©e',
      'ips_pr': 'IPS',
      'adresse_pr': 'Adresse'
    }
  },
  labels: {
    enabled: false,
    field: 'ips_pu',
    textSize: 12,
    color: '#333',
    haloColor: 'rgba(255,255,255,0.8)',
    haloWidth: 2,
    labelFormat: 'number-1'
  },
  minzoom: 8,
  maxzoom: 22
},
top_colleges: {
  source: { 
    type: 'vector', 
    url: 'mapbox://hadrienleger.1nte6eib'  // √Ä remplacer
  },
  sourceLayer: 'top_colleges-bwea0c',  // √Ä remplacer
  isChoropleth: true,
  property: 'note_college',
  breaks: [8, 10.29, 12.29, 14.57],  // √Ä ajuster selon vos donn√©es
  colors: ['#D2E3F9', '#9FC2F4', '#5C9CED', '#2F6BC7', '#0F3B66'],
  nullColor: '#d3d3d3',
  opacity: 0.8,
  clickable: true,
  popup: {
    fields: ['nom_iris', 'nom_college', 'note_college', 'adresse_college', 'secteur', 'etat'],
    fieldLabels: {
      'nom_iris': 'Quartier',
      'nom_college': 'Meilleur coll√®ge rattach√© par la carte scolaire',
      'note_college': 'Note /20',
      'adresse_college': 'Adresse',
      'secteur': 'Public/priv√©',
      'etat': 'Ouvert/Ferm√©'
    }
  },
  labels: {
    enabled: false,
    field: 'note_college',
    textSize: 12,
    color: '#333',
    haloColor: 'rgba(255,255,255,0.8)',
    haloWidth: 2,
    labelFormat: 'number-1'
  },
  minzoom: 8,
  maxzoom: 22
},
      points_colleges: {
        source: { 
          type: 'vector', 
          url: 'mapbox://hadrienleger.99z0ngtm'  // √Ä remplacer
        },
        sourceLayer: 'points_colleges-13ermp',  // √Ä remplacer
              isPoints: true,
              paint: {
                'circle-radius': ['interpolate', ['linear'], ['zoom'], 11, 4, 15, 8],
                'circle-color': '#4CAF50',
                'circle-stroke-color': '#ffffff',
                'circle-stroke-width': 2,
                'circle-opacity': 0.8
              },
              clickable: true,
        popup: {
          fields: ['nom_college', 'note_college', 'adresse_college', 'secteur', 'etat', 'noms_iris'],
          fieldLabels: {
            'nom_college': 'Coll√®ge',
            'note_college': 'Note /20',
            'adresse_college': 'Adresse',
            'secteur': 'Public/priv√©',
            'etat': 'Ouvert/Ferm√©',
            'noms_iris': 'Quartiers rattach√©s selon la carte scolaire'
          }
        },
        minzoom: 10,
        maxzoom: 22
      },
part_log_soc: {
  source: { 
    type: 'vector', 
    url: 'mapbox://hadrienleger.6drw6ii3'  // √Ä remplacer
  },
  sourceLayer: 'part_log_soc-4u7xad',  // √Ä remplacer
  isChoropleth: true,
  property: 'part_log_soc',
  breaks: [0.065, 0.2, 0.41, 0.695],
  colors: ['#D2E3F9', '#9FC2F4', '#5C9CED', '#2F6BC7', '#0F3B66'],
  nullColor: '#d3d3d3',
  opacity: 0.8,
  clickable: true,
  popup: {
    fields: ['nom_iris', 'part_log_soc', 'nb_logsoc', 'txlsplai', 'txlsplus', 'txlspls', 'txlspli'],
    fieldLabels: {
      'nom_iris': 'Nom du quartier',
      'part_log_soc': 'Pourcentage de logements sociaux',
      'nb_logsoc': 'Nombre de logements sociaux',
      'txlsplai': 'Part des logements sociaux PLAI',
      'txlsplus': 'Part des logements sociaux PLUS (ex-HLM)',
      'txlspls': 'Part des logements sociaux PLS',
      'txlspli': 'Part des logements sociaux PLI'
    },
    format: {
      'part_log_soc': 'percent-0' // Formatage en pourcentage sans d√©cimales
    }
  },
  labels: {
    enabled: false,
    field: 'part_log_soc',
    textSize: 12,
    color: '#333',
    haloColor: 'rgba(255,255,255,0.8)',
    haloWidth: 2,
    labelFormat: 'number-1'
  },
  minzoom: 8,
  maxzoom: 22
},
points_logsoc_regions1: {
  source: { 
    type: 'vector', 
    url: 'mapbox://hadrienleger.3mz24mlc'
  },
  sourceLayer: 'points_logsoc_regions1-9dcope',
  isPoints: true,
  paint: {
    'circle-radius': [
      'interpolate',
      ['exponential', 0.5],
      ['get', 'nb_logements'],
      1, 3,
      10, 6,
      30, 10,
      60, 15,
      100, 20,
      200, 25
    ],
    'circle-color': '#8B4513',
    'circle-stroke-color': '#ffffff',
    'circle-stroke-width': [
      'interpolate',
      ['linear'],
      ['zoom'],
      10, 0.5,
      15, 2
    ],
    'circle-opacity': 0.8
  },
  clickable: true,
  popup: {
    fields: ['adresse', 'codepostal', 'libcom', 'nb_logements', 'nb_plai', 'nb_plus', 'nb_pls', 'nb_pli', 'nb_autres', 'bat', 'immeu'],
    fieldLabels: {
      'adresse': 'Adresse',
      'codepostal': 'Code postal',
      'libcom': 'Commune',
      'nb_logements': 'Nombre de logements sociaux',
      'nb_plai': 'Logements de type PLAI',
      'nb_plus': 'Logements de type PLUS',
      'nb_pls': 'Logements de type PLS',
      'nb_pli': 'Logements de type PLI',
      'nb_autres': 'Logements de type Autres',
      'bat': 'B√¢timent',
      'immeu': 'Immeuble'
    }
  },
  minzoom: 10,
  maxzoom: 22
},
points_logsoc_regions2: {
  source: { 
    type: 'vector', 
    url: 'mapbox://hadrienleger.08rj6o2k'
  },
  sourceLayer: 'points_logsoc_regions2-4sv755',
  isPoints: true,
  paint: {
    'circle-radius': [
      'interpolate',
      ['exponential', 0.5],
      ['get', 'nb_logements'],
      1, 3,
      10, 6,
      30, 10,
      60, 15,
      100, 20,
      200, 25
    ],
    'circle-color': '#8B4513',
    'circle-stroke-color': '#ffffff',
    'circle-stroke-width': [
      'interpolate',
      ['linear'],
      ['zoom'],
      10, 0.5,
      15, 2
    ],
    'circle-opacity': 0.8
  },
  clickable: true,
  popup: {
    fields: ['adresse', 'codepostal', 'libcom', 'nb_logements', 'nb_plai', 'nb_plus', 'nb_pls', 'nb_pli', 'nb_autres', 'bat', 'immeu'],
    fieldLabels: {
      'adresse': 'Adresse',
      'codepostal': 'Code postal',
      'libcom': 'Commune',
      'nb_logements': 'Nombre de logements sociaux',
      'nb_plai': 'Logements de type PLAI',
      'nb_plus': 'Logements de type PLUS',
      'nb_pls': 'Logements de type PLS',
      'nb_pli': 'Logements de type PLI',
      'nb_autres': 'Logements de type Autres',
      'bat': 'B√¢timent',
      'immeu': 'Immeuble'
    }
  },
  minzoom: 10,
  maxzoom: 22
},
magasins_bio: {
    source: { 
      type: 'vector', 
      url: 'mapbox://hadrienleger.2hy4pin8'
    },
    sourceLayer: 'magasins_bio-b1pigw',
    isPoints: true,
    paint: {
      'circle-radius': ['interpolate', ['linear'], ['zoom'], 11, 4, 15, 8],
      'circle-color': '#4CAF50',
      'circle-stroke-color': '#ffffff',
      'circle-stroke-width': 2,
      'circle-opacity': 0.8
    },
    clickable: true,
    popup: {
      fields: ['nom', 'prod_nom', 'adresse'],
      // Mapping pour affichage √©l√©gant
      fieldLabels: {
        'nom': 'Nom',
        'prod_nom': 'Type de magasin',
        'adresse': 'Adresse'
      }
    },
    minzoom: 10,
    maxzoom: 22
  },
  securite_communes: {
  source: { 
    type: 'vector', 
    url: 'mapbox://hadrienleger.7ar67jl5'
  },
  sourceLayer: 'securite_communes-81jxzi',
  isChoropleth: true,
  property: 'note_v1',  // Valeur initiale par d√©faut
  breaks: [8.91, 11.73, 13.85, 17.58],
  colors: ['#D2E3F9', '#9FC2F4', '#5C9CED', '#2F6BC7', '#0F3B66'], // 5 couleurs
  nullColor: '#d3d3d3', // Gris clair pour les valeurs nulles
  opacity: 0.8,
  clickable: true,
  popup: {
    fields: ['libelle_commune', 'note_v1'],
    // Mapping pour affichage √©l√©gant
    fieldLabels: {
      'libelle_commune': 'Nom de la commune',
      'note_v1': 'Note de s√©curit√© /20'
    }
  },
  labels: {
    enabled: false,
    field: 'note_v1',  // Valeur initiale par d√©faut
    textSize: 12,
    color: '#333',
    haloColor: 'rgba(255,255,255,0.8)',
    haloWidth: 2,
    labelFormat: 'number-1'
  },
   minzoom: 8,
   maxzoom: 22
      },
prix_median: {
  source: { 
    type: 'vector', 
    url: 'mapbox://hadrienleger.7dx7aj7b'
  },
  sourceLayer: 'prixmedians_2024_s1-dryw5c',
  isChoropleth: true,
  property: 'prix_median',
  
  // Breaks multiscales extraits du JSON
  breaksConfig: {
    national: [1932, 3659, 7207, 28478],
    
    regional: {
      'ARA': [1591, 2694, 3991, 6425],
      'HDF': [1125, 1708, 2356, 3321],
      'PAC': [2616, 4103, 6262, 13871],
      'GES': [842, 1469, 2232, 4762],
      'OCC': [1169, 1915, 2733, 3810],
      'NOR': [1315, 1939, 2636, 3956],
      'NAQ': [1483, 2847, 5000, 13201],
      'CVL': [1082, 1694, 2413, 6875],
      'BFC': [953, 1615, 2464, 4947],
      'BRE': [1562, 2327, 3280, 4623],
      'COR': [1481, 2738, 4104, 5905],
      'PDL': [1343, 2063, 2902, 4141],
      'IDF': [3451, 5449, 8167, 12074]
    },
    
    departmental: {
      '01': [1333, 2050, 2773, 3833],
      '02': [775, 1250, 1702, 2491],
      '03': [685, 1144, 1622, 2308],
      '04': [1254, 1931, 2692, 4014],
      '05': [976, 1900, 2645, 3468],
      '06': [2653, 4211, 5694, 8410],
      '07': [1470, 2250, 3275, 4636],
      '08': [598, 1054, 1565, 2348],
      '09': [967, 1583, 2341, 3873],
      '10': [795, 1251, 1715, 2396],
      '11': [812, 1358, 1948, 2926],
      '12': [764, 1300, 1807, 2505],
      '13': [2704, 4075, 6115, 13140],
      '14': [1756, 2594, 3490, 5150],
      '15': [600, 986, 1377, 1819],
      '16': [710, 1128, 1508, 1978],
      '17': [1480, 2481, 3714, 5588],
      '18': [731, 1181, 1668, 2675],
      '19': [731, 1175, 1571, 2077],
      '21': [1123, 1910, 2680, 4484],
      '22': [1333, 1986, 2768, 4065],
      '23': [451, 798, 1217, 1727],
      '24': [948, 1492, 2068, 3094],
      '25': [1298, 2062, 2928, 4823],
      '26': [1571, 2374, 3162, 5514],
      '27': [1296, 1827, 2320, 3233],
      '28': [1243, 1724, 2226, 3125],
      '29': [1274, 1798, 2305, 2966],
      '2A': [1875, 3333, 4556, 5618],
      '2B': [1390, 2508, 3320, 4391],
      '30': [1568, 2361, 3059, 4018],
      '31': [1404, 2222, 2967, 3926],
      '32': [827, 1414, 2000, 2857],
      '33': [2478, 3869, 7000, 13201],
      '34': [1649, 2604, 3447, 4320],
      '35': [1741, 2485, 3381, 4527],
      '36': [418, 770, 1084, 1459],
      '37': [1214, 1823, 2376, 3026],
      '38': [1844, 2602, 3398, 4952],
      '39': [1189, 1855, 2746, 4947],
      '40': [1464, 2413, 3442, 5500],
      '41': [1185, 1698, 2982, 10143],
      '42': [1190, 1800, 2511, 3986],
      '43': [538, 1032, 1484, 2061],
      '44': [1968, 2777, 3542, 4688],
      '45': [1139, 1714, 2385, 4099],
      '46': [896, 1462, 1886, 2400],
      '47': [799, 1335, 1816, 2533],
      '48': [760, 1406, 2018, 3209],
      '49': [1400, 1912, 2430, 3119],
      '50': [1180, 1692, 2213, 3000],
      '51': [1300, 2006, 2835, 4762],
      '52': [508, 916, 1327, 1877],
      '53': [837, 1279, 1750, 2575],
      '54': [867, 1476, 2091, 2893],
      '55': [688, 1191, 1765, 2618],
      '56': [1817, 2758, 3939, 5472],
      '58': [615, 952, 1392, 1900],
      '59': [1188, 1759, 2410, 3278],
      '60': [1370, 1939, 2503, 3373],
      '61': [856, 1365, 1925, 2923],
      '62': [1183, 1820, 2667, 4310],
      '63': [886, 1474, 2007, 2551],
      '64': [1623, 2938, 4459, 6196],
      '65': [1136, 1851, 2786, 4137],
      '66': [1273, 2038, 2947, 4598],
      '69': [2169, 3205, 4140, 5223],
      '70': [800, 1349, 1911, 3001],
      '71': [929, 1390, 1831, 2529],
      '72': [873, 1273, 1623, 2028],
      '73': [2160, 3211, 4542, 7231],
      '74': [2949, 4164, 5448, 7537],
      '75': [8471, 10616, 13548, 18218],
      '76': [1215, 1750, 2219, 2772],
      '77': [1693, 2403, 3103, 3895],
      '78': [2659, 3554, 4578, 6071],
      '79': [579, 1011, 1417, 1867],
      '80': [984, 1456, 1988, 2784],
      '81': [1059, 1633, 2190, 3015],
      '82': [1091, 1555, 1981, 2467],
      '83': [3190, 4823, 7806, 11188],
      '84': [1667, 2475, 3272, 4684],
      '85': [1475, 2193, 3162, 4688],
      '86': [815, 1243, 1690, 2192],
      '87': [750, 1094, 1472, 1819],
      '88': [677, 1180, 1700, 2519],
      '89': [923, 1495, 2269, 3722],
      '90': [682, 1291, 1667, 2093],
      '91': [2150, 2888, 3577, 4465],
      '92': [4266, 5812, 7078, 8844],
      '93': [2900, 3979, 5385, 7846],
      '94': [3556, 4562, 5625, 7136],
      '95': [2455, 3152, 3770, 4588]
    }
  },
  
  // Niveau actuel par d√©faut
  scaleLevel: 'national',
  
  // Breaks actifs (initialis√©s avec le national)
  breaks: [1932, 3659, 7207, 28478],
  
  colors: ['#D2E3F9', '#9FC2F4', '#5C9CED', '#2F6BC7', '#0F3B66'],
  nullColor: '#d3d3d3',
  opacity: 0.8,
  clickable: true,
  popup: {
    fields: ['nom_iris', 'prix_median', 'prix_moyen'],
    fieldLabels: {
      'nom_iris': 'Quartier',
      'prix_median': 'Prix m√©dian au m¬≤',
      'prix_moyen': 'Prix moyen au m¬≤'
    }
  },
  labels: {
    enabled: false,
    field: 'prix_median',
    textSize: 12,
    color: '#333',
    haloColor: 'rgba(255,255,255,0.8)',
    haloWidth: 2,
    labelFormat: 'currency-euro'
  },
  minzoom: 8,
  maxzoom: 22
}
    };

///// LAYER MANAGER //////
/**
/**
 * GESTIONNAIRE DE LAYERS - Version 4 FINALE
 * Remplace compl√®tement le syst√®me zoomToIris
 */
/**
 * GESTIONNAIRE DE LAYERS - Version 4 FINALE
 * Remplace compl√®tement le syst√®me zoomToIris
 */
window.layerManager = {
  // √âtat des layers par outil
  state: {
    trouver: {
      activeLayers: new Set(),
      irisData: null,              // codes IRIS affich√©s
      hasSearchArea: false,        // zone de recherche active  
      radiusMarker: null           // coordonn√©es du marqueur radius {lon, lat}
    },
    explorer: {
      activeLayers: new Set(),
      irisData: null,              // codes IRIS affich√©s  
      hasSearchArea: false,        // zone de recherche active
      addressMarker: null          // coordonn√©es du marqueur d'adresse {lon, lat}
    }
  },
  
  // Outil actuel
  currentTool: 'trouver',  // Par d√©faut sur Trouver
  
  // Layer choropl√®the actif (un seul √† la fois)
  activeChloropleth: null,
  
  // Popups actives
  activePopups: [],

  /**
   * Initialise le gestionnaire
   */
  init() {
    console.log('üé® LayerManager initialized');
    
    // S'assurer que toutes les sources sont ajout√©es
    if (window.map && window.map.loaded()) {
      this.ensureAllSources();
    } else if (window.map) {
      window.map.on('load', () => this.ensureAllSources());
    }
  },

  /**
   * Ajoute toutes les sources n√©cessaires
   */
  ensureAllSources() {
    Object.entries(window.layerConfigs).forEach(([layerId, config]) => {
      if (!window.map.getSource(layerId)) {
        try {
          window.map.addSource(layerId, config.source);
          console.log(`‚úÖ Source ${layerId} added`);
        } catch (error) {
          console.error(`‚ùå Error adding source ${layerId}:`, error);
        }
      }
    });
  },

  /**
   * Bascule entre les outils - FONCTION PRINCIPALE
   */
  switchTool(newTool) {
    if (newTool === this.currentTool) {
      console.log(`‚ÑπÔ∏è D√©j√† sur l'outil ${newTool}`);
      return;
    }

    console.log(`üîÑ Basculement ${this.currentTool} ‚Üí ${newTool}`);

    // 1. SAUVEGARDER l'√©tat actuel
    this.saveCurrentState();

    // 2. MASQUER tout de l'outil actuel
    this.hideAllCurrentLayers();

    // 3. CHANGER l'outil
    const oldTool = this.currentTool;
    this.currentTool = newTool;

    // 4. RESTAURER l'√©tat du nouvel outil
    this.restoreToolState();

    // 5. Notifier Bubble
    this.notifyBubble('tool_switched', { oldTool, newTool });
    
    console.log(`‚úÖ Basculement termin√© vers ${newTool}`);
  },

  /**
   * SAUVEGARDE l'√©tat complet de l'outil actuel
   */
  saveCurrentState() {
    const currentState = this.state[this.currentTool];
    
    console.log(`üíæ Sauvegarde √©tat ${this.currentTool}:`);
    
    // Sauvegarder IRIS actuels (en regardant quels layers IRIS sont actifs)
    if (currentState.irisData && currentState.irisData.length > 0) {
      console.log(`  üìç IRIS sauvegard√©s:`, currentState.irisData);
    } else {
      currentState.irisData = null;
      console.log(`  üìç Aucun IRIS √† sauvegarder`);
    }
    
    // Sauvegarder zone de recherche - CORRECTION ICI
    const hasCollectivites = window.collectivitesData?.features?.length > 0;
    const hasRadius = window.radiusData?.features?.length > 0;
    const hasVisibleCollectivites = hasCollectivites && window.map.getLayer('collectivites-fill') && 
                                   window.map.getLayoutProperty('collectivites-fill', 'visibility') === 'visible';
    const hasVisibleRadius = hasRadius && window.map.getLayer('radius-fill') && 
                            window.map.getLayoutProperty('radius-fill', 'visibility') === 'visible';
    
    currentState.hasSearchArea = hasVisibleCollectivites || hasVisibleRadius;
    console.log(`  üîç Zone de recherche visible:`, currentState.hasSearchArea);
    console.log(`    - Collectivit√©s:`, hasVisibleCollectivites);
    console.log(`    - Rayon:`, hasVisibleRadius);
    
    // Sauvegarder marqueur d'adresse (Explorer uniquement)
    if (this.currentTool === 'explorer' && window.addressMarker) {
      const lngLat = window.addressMarker.getLngLat();
      currentState.addressMarker = { lon: lngLat.lng, lat: lngLat.lat };
      console.log(`  üìç Marqueur adresse sauvegard√©:`, currentState.addressMarker);
    }
    
    // Sauvegarder marqueur radius (Trouver uniquement)
    if (this.currentTool === 'trouver' && window.radiusMarker) {
      const lngLat = window.radiusMarker.getLngLat();
      currentState.radiusMarker = { lon: lngLat.lng, lat: lngLat.lat };
      console.log(`  üìç Marqueur radius sauvegard√©:`, currentState.radiusMarker);
    }
    
    // Les activeLayers sont d√©j√† √† jour via addMapLayer/removeMapLayer
    console.log(`  üé® Layers actifs:`, Array.from(currentState.activeLayers));
  },

  /**
   * MASQUE tout de l'outil actuel
   */
  hideAllCurrentLayers() {
    console.log(`üôà Masquage layers ${this.currentTool}`);
    
    // 1. Masquer choropl√®thes
    if (this.activeChloropleth) {
      window.hideChoropleth();
      console.log(`  üé® Choropl√®the masqu√©: ${this.activeChloropleth}`);
    }
    
    // 2. Masquer layers de points
    this.state[this.currentTool].activeLayers.forEach(layerId => {
      const config = window.layerConfigs[layerId];
      if (config?.isPoints) {
        const pointLayerId = `${layerId}-points`;
        if (window.map.getLayer(pointLayerId)) {
          window.map.setLayoutProperty(pointLayerId, 'visibility', 'none');
          console.log(`  üìç Points masqu√©s: ${layerId}`);
        }
      }
    });
    
    // 3. Masquer TOUS les IRIS (ancien et nouveau syst√®me)
    this.hideAllIrisLayers();
    console.log(`  üèòÔ∏è TOUS les IRIS masqu√©s`);
    
    // 4. Masquer zone de recherche
    this.hideSearchArea();
    console.log(`  üîç Zone de recherche masqu√©e`);
    
    // 5. Masquer marqueurs selon l'outil
    if (this.currentTool === 'explorer' && window.addressMarker) {
      window.addressMarker.remove();
      window.addressMarker = null;
      console.log(`  üìç Marqueur adresse Explorer masqu√©`);
    }
    
    if (this.currentTool === 'trouver' && window.radiusMarker) {
      window.radiusMarker.remove();
      window.radiusMarker = null;
      console.log(`  üìç Marqueur radius Trouver masqu√©`);
    }
    
    // 6. Fermer popups
    this.closeAllPopups();
  },

  /**
   * RESTAURE l'√©tat du nouvel outil
   */
  restoreToolState() {
    const newState = this.state[this.currentTool];
    
    console.log(`üîÑ Restauration ${this.currentTool}:`);
    console.log(`  √âtat √† restaurer:`, newState);
    
    // 1. Restaurer zone de recherche d'abord
    if (newState.hasSearchArea) {
      this.restoreSearchArea();
      console.log(`  üîç Zone de recherche restaur√©e`);
    }
    
    // 2. Restaurer IRIS
    if (newState.irisData && newState.irisData.length > 0) {
      console.log(`  üìç Restauration IRIS:`, newState.irisData);
      this.displayIrisForTool(this.currentTool, newState.irisData, false); // false = pas de zoom
    }
    
    // 3. Restaurer choropl√®the (Explorer uniquement)
    if (this.currentTool === 'explorer') {
      const choroplethLayer = Array.from(newState.activeLayers)
        .find(layerId => window.layerConfigs[layerId]?.isChoropleth);
      
      if (choroplethLayer) {
        window.showChoroplethLayer(choroplethLayer);
        this.activeChloropleth = choroplethLayer;
        console.log(`  üé® Choropl√®the restaur√©: ${choroplethLayer}`);
      }
      
      // 4. Restaurer layers de points (Explorer uniquement)
      newState.activeLayers.forEach(layerId => {
        const config = window.layerConfigs[layerId];
        if (config?.isPoints) {
          const pointLayerId = `${layerId}-points`;
          if (window.map.getLayer(pointLayerId)) {
            window.map.setLayoutProperty(pointLayerId, 'visibility', 'visible');
            console.log(`  üìç Points restaur√©s: ${layerId}`);
          } else {
            // Re-cr√©er le layer s'il n'existe plus
            this.addPointsLayer(layerId, config);
            console.log(`  üìç Points re-cr√©√©s: ${layerId}`);
          }
        }
      });
    }
    
    // 5. Restaurer marqueurs selon l'outil
    if (this.currentTool === 'explorer' && newState.addressMarker && !window.addressMarker) {
      window.addressMarker = new mapboxgl.Marker({ color: '#ff0066' })
        .setLngLat([newState.addressMarker.lon, newState.addressMarker.lat])
        .addTo(window.map);
      console.log(`  üìç Marqueur adresse Explorer restaur√©`);
    }
    
    if (this.currentTool === 'trouver' && newState.radiusMarker && !window.radiusMarker) {
      window.radiusMarker = new mapboxgl.Marker({ color: '#8A2BE2' })
        .setLngLat([newState.radiusMarker.lon, newState.radiusMarker.lat])
        .addTo(window.map);
      console.log(`  üìç Marqueur radius Trouver restaur√©`);
    }
    
    console.log(`‚úÖ Restauration ${this.currentTool} termin√©e`);
  },

  /**
   * Affiche des IRIS pour un outil sp√©cifique
   * Cette fonction remplace compl√®tement zoomToIris/zoomToIrisQueued
   */
  displayIrisForTool(tool, codes, withZoom = true) {
    if (!codes || codes.length === 0) return;
    
    console.log(`üèòÔ∏è Affichage IRIS pour ${tool}:`, codes, withZoom ? '(avec zoom)' : '(sans zoom)');
    
    // Attendre que la carte soit pr√™te
    if (!window.map || !window.map.loaded()) {
      console.log('‚è≥ Carte pas pr√™te, attente...');
      setTimeout(() => this.displayIrisForTool(tool, codes, withZoom), 200);
      return;
    }
    
    // Noms de layers sp√©cifiques √† l'outil
    const fillLayerId = `iris-${tool}-fill`;
    const outlineLayerId = `iris-${tool}-outline`;
    
    // S'assurer que la source IRIS existe
    if (!window.map.getSource('iris')) {
      window.map.addSource('iris', window.layerConfigs['iris'].source);
      console.log('‚ûï Source IRIS ajout√©e');
    }

    // Nettoyer TOUS les layers IRIS existants (pour √™tre s√ªr)
    this.hideAllIrisLayers();

    // R√©initialiser tous les feature-states pour √©viter les couleurs parasites
    this.resetAllIrisFeatureStates();

    // Cr√©er les nouveaux layers avec des valeurs explicites
    try {
      // Layer de remplissage avec couleur FORC√âE
      window.map.addLayer({
        id: fillLayerId,
        type: 'fill',
        source: 'iris',
        'source-layer': window.layerConfigs['iris'].sourceLayer,
        paint: {
          'fill-color': '#8A2BE2',  // Couleur EXPLICITE
          'fill-opacity': 0.25      // Opacity EXPLICITE  
        },
        filter: ['match', ['get', 'CODE_IRIS'], codes, true, false]
      });

      // Forcer la couleur apr√®s cr√©ation du layer (au cas o√π)
      window.map.setPaintProperty(fillLayerId, 'fill-color', '#8A2BE2');
      window.map.setPaintProperty(fillLayerId, 'fill-opacity', 0.25);

      // Layer de contour avec couleur FORC√âE
      window.map.addLayer({
        id: outlineLayerId,
        type: 'line',
        source: 'iris',
        'source-layer': window.layerConfigs['iris'].sourceLayer,
        paint: {
          'line-color': '#8A2BE2',  // Couleur EXPLICITE
          'line-width': 2,
          'line-opacity': 1
        },
        filter: ['match', ['get', 'CODE_IRIS'], codes, true, false]
      });

      // Forcer la couleur apr√®s cr√©ation du layer (au cas o√π)
      window.map.setPaintProperty(outlineLayerId, 'line-color', '#8A2BE2');

      console.log(`‚úÖ IRIS ${tool} cr√©√©s: ${fillLayerId}, ${outlineLayerId}`);

      // FORCER les couleurs apr√®s cr√©ation (toujours, m√™me en cas de retry)
      setTimeout(() => {
        if (window.map.getLayer(fillLayerId)) {
          window.map.setPaintProperty(fillLayerId, 'fill-color', '#8A2BE2');
          window.map.setPaintProperty(fillLayerId, 'fill-opacity', 0.25);
          console.log(`üé® Couleurs forc√©es pour ${fillLayerId}`);
        }
        if (window.map.getLayer(outlineLayerId)) {
          window.map.setPaintProperty(outlineLayerId, 'line-color', '#8A2BE2');
          console.log(`üé® Couleurs forc√©es pour ${outlineLayerId}`);
        }
      }, 100);

      // Ajouter les interactions de clic
      this.addIrisClickListeners(fillLayerId);
      
      // S'assurer que les layers de s√©lection existent
      this.ensureIrisSelectedLayers();
      
      // Mettre √† jour window.lastIrisList pour compatibilit√©
      window.lastIrisList = codes.slice();

      // ZOOM D√âSACTIV√â pour √©viter les probl√®mes de redimensionnement Bubble
      // Les IRIS s'affichent √† la position actuelle de la carte
      
    } catch (error) {
      console.error(`‚ùå Erreur affichage IRIS ${tool}:`, error);
    }
  },

  /**
   * Calcule et applique le fitBounds sur les IRIS
   */
  fitBoundsToIris(codes) {
    try {
      const features = window.map.querySourceFeatures('iris', {
        sourceLayer: window.layerConfigs['iris'].sourceLayer,
        filter: ['match', ['get', 'CODE_IRIS'], codes, true, false]
      });

      if (features.length > 0) {
        const fc = {
          type: 'FeatureCollection',
          features: features
        };
        
        const bbox = turf.bbox(fc);
        window.map.fitBounds(bbox, { 
          padding: 60, 
          duration: 600,
          maxZoom: 15
        });
        
        console.log('üéØ Zoom appliqu√© sur les IRIS');
      }
    } catch (error) {
      console.error('‚ùå Erreur zoom IRIS:', error);
    }
  },

  /**
   * Ajoute les listeners de clic sur les IRIS
   */
  addIrisClickListeners(layerId) {
    // Retirer les anciens listeners pour √©viter les doublons
    window.map.off('click', layerId);
    window.map.off('mouseenter', layerId);
    window.map.off('mouseleave', layerId);
    
    window.map.on('click', layerId, e => {
      const codeIris = e.features[0].properties['CODE_IRIS'];
      console.log('IRIS cliqu√©:', codeIris);
      window.selectGeometry('iris', codeIris);
    });
    
    window.map.on('mouseenter', layerId, () => {
      window.map.getCanvas().style.cursor = 'pointer';
    });
    
    window.map.on('mouseleave', layerId, () => {
      window.map.getCanvas().style.cursor = '';
    });
    
    console.log(`üñ±Ô∏è Listeners ajout√©s pour ${layerId}`);
  },

  /**
   * R√©initialise tous les feature-states IRIS (maintenant optionnel)
   */
  resetAllIrisFeatureStates() {
    // Cette fonction est maintenant moins critique car on n'utilise plus feature-state
    // pour les couleurs, mais on la garde pour la s√©lection
    if (!window.map || !window.map.getSource('iris')) return;
    
    try {
      const features = window.map.querySourceFeatures('iris', {
        sourceLayer: window.layerConfigs['iris'].sourceLayer
      });
      
      features.forEach(feature => {
        if (feature.id !== undefined) {
          window.map.setFeatureState(
            { source: 'iris', sourceLayer: window.layerConfigs['iris'].sourceLayer, id: feature.id },
            { clicked: false }
          );
        }
      });
      
      console.log(`üé® Feature-states r√©initialis√©s pour ${features.length} IRIS`);
    } catch (error) {
      console.log('‚ö†Ô∏è R√©initialisation feature-states ignor√©e:', error.message);
    }
  },
  ensureIrisSelectedLayers() {
    if (!window.map || !window.map.getSource('iris')) return;

    if (!window.map.getLayer('iris-selected-fill')) {
      window.map.addLayer({
        id: 'iris-selected-fill',
        type: 'fill',
        source: 'iris',
        'source-layer': window.layerConfigs.iris.sourceLayer,
        paint: {
          'fill-color': 'rgba(255,215,0,0.35)',
          'fill-opacity': 0.8
        },
        filter: ['==', ['get', 'CODE_IRIS'], '']
      });
    }

    if (!window.map.getLayer('iris-selected-outline')) {
      window.map.addLayer({
        id: 'iris-selected-outline',
        type: 'line',
        source: 'iris',
        'source-layer': window.layerConfigs.iris.sourceLayer,
        paint: { 'line-color': '#FFD700', 'line-width': 3 },
        filter: ['==', ['get', 'CODE_IRIS'], '']
      });
    }
  },

  /**
   * Gestion des IRIS avec sauvegarde d'√©tat (API publique)
   * REMPLACE zoomToIrisQueued
   */
  showIrisForTool(codes) {
    console.log(`üìç showIrisForTool(${this.currentTool}):`, codes);
    
    // Sauvegarder dans l'√©tat
    this.state[this.currentTool].irisData = codes ? codes.slice() : null;
    
    if (codes && codes.length > 0) {
      // Afficher SANS zoom automatique
      this.displayIrisForTool(this.currentTool, codes, false);
    } else {
      // Masquer tous les IRIS
      this.hideAllIrisLayers();
    }
  },

  /**
   * Masque TOUS les layers IRIS (syst√®me unifi√©)
   */
  hideAllIrisLayers() {
    // Tous les layers IRIS possibles
    const allIrisLayers = [
      // Ancien syst√®me
      'iris-temp', 'iris-temp-outline', 'iris-fill', 'iris-outline', 'iris-labels',
      // Nouveau syst√®me par outil
      'iris-trouver-fill', 'iris-trouver-outline',
      'iris-explorer-fill', 'iris-explorer-outline',
      // Layers de s√©lection
      'iris-selected-fill', 'iris-selected-outline'
    ];
    
    allIrisLayers.forEach(layerId => {
      if (window.map.getLayer(layerId)) {
        try {
          window.map.removeLayer(layerId);
          console.log(`üóëÔ∏è Layer IRIS supprim√©: ${layerId}`);
        } catch (error) {
          // Ignorer les erreurs de suppression
        }
      }
    });
  },

  /**
   * Ajoute un layer (API Bubble)
   */
  addLayer(layerId) {
    const config = window.layerConfigs[layerId];
    if (!config) {
      console.error(`‚ùå Layer ${layerId} not found in config`);
      return false;
    }

    console.log(`‚ûï Ajout layer ${layerId} pour ${this.currentTool}`);

    // V√©rifier les r√®gles d'exclusivit√© pour les choropl√®thes
    if (config.isChoropleth) {
      if (this.activeChloropleth && this.activeChloropleth !== layerId) {
        this.removeLayer(this.activeChloropleth);
      }
      this.activeChloropleth = layerId;
      
      // Utiliser la fonction existante pour les choropl√®thes
      window.showChoroplethLayer(layerId);
    } else if (config.isPoints) {
      // Ajouter le layer de points
      this.addPointsLayer(layerId, config);
    } else {
      console.warn(`‚ö†Ô∏è Layer type not fully supported: ${layerId}`);
      return false;
    }

    // Mettre √† jour l'√©tat
    this.state[this.currentTool].activeLayers.add(layerId);
    
    // Notifier Bubble
    this.notifyBubble('layer_added', { layerId, tool: this.currentTool });
    
    return true;
  },

  /**
   * Supprime un layer (API Bubble)
   */
  removeLayer(layerId) {
    const config = window.layerConfigs[layerId];
    if (!config) return false;

    console.log(`‚ûñ Suppression layer ${layerId} pour ${this.currentTool}`);

    // Supprimer selon le type
    if (config.isPoints) {
      const pointLayerId = `${layerId}-points`;
      if (window.map.getLayer(pointLayerId)) {
        window.map.setLayoutProperty(pointLayerId, 'visibility', 'none');
      }
    } else if (config.isChoropleth) {
      window.hideChoropleth();
      if (this.activeChloropleth === layerId) {
        this.activeChloropleth = null;
      }
    }

    // Mettre √† jour l'√©tat
    this.state[this.currentTool].activeLayers.delete(layerId);
    
    // Fermer les popups associ√©s
    this.closeAllPopups();
    
    // Notifier Bubble
    this.notifyBubble('layer_removed', { layerId, tool: this.currentTool });
    
    return true;
  },

  /**
   * Ajoute un layer de points
   */
  addPointsLayer(layerId, config) {
    const pointLayerId = `${layerId}-points`;
    
    // S'assurer que la source existe
    if (!window.map.getSource(layerId)) {
      window.map.addSource(layerId, config.source);
    }
    
    if (!window.map.getLayer(pointLayerId)) {
      window.map.addLayer({
        id: pointLayerId,
        type: 'circle',
        source: layerId,
        'source-layer': config.sourceLayer,
        paint: config.paint,
        minzoom: config.minzoom || 0,
        maxzoom: config.maxzoom || 22
      });

      // Ajouter les interactions si clickable
      if (config.clickable) {
        window.map.on('click', pointLayerId, (e) => this.handlePointClick(e, layerId, config));
        window.map.on('mouseenter', pointLayerId, () => {
          window.map.getCanvas().style.cursor = 'pointer';
        });
        window.map.on('mouseleave', pointLayerId, () => {
          window.map.getCanvas().style.cursor = '';
        });
      }
    } else {
      window.map.setLayoutProperty(pointLayerId, 'visibility', 'visible');
    }
  },

  /**
   * Masque la zone de recherche
   */
  hideSearchArea() {
    // Masquer collectivit√©s
    ['collectivites-fill', 'collectivites-outline'].forEach(layerId => {
      if (window.map.getLayer(layerId)) {
        window.map.setLayoutProperty(layerId, 'visibility', 'none');
      }
    });
    
    // Masquer rayon
    ['radius-fill', 'radius-outline'].forEach(layerId => {
      if (window.map.getLayer(layerId)) {
        window.map.setLayoutProperty(layerId, 'visibility', 'none');
      }
    });
  },

  /**
   * Restaure la zone de recherche
   */
  restoreSearchArea() {
    // Restaurer collectivit√©s si donn√©es disponibles
    if (window.collectivitesData?.features?.length > 0) {
      ['collectivites-fill', 'collectivites-outline'].forEach(layerId => {
        if (window.map.getLayer(layerId)) {
          window.map.setLayoutProperty(layerId, 'visibility', 'visible');
        }
      });
    }
    
    // Restaurer rayon si donn√©es disponibles  
    if (window.radiusData?.features?.length > 0) {
      ['radius-fill', 'radius-outline'].forEach(layerId => {
        if (window.map.getLayer(layerId)) {
          window.map.setLayoutProperty(layerId, 'visibility', 'visible');
        }
      });
    }
  },

  /**
   * G√®re le clic sur un point
   */
  handlePointClick(e, layerId, config) {
    if (!config.popup || !config.popup.fields) return;

    const coordinates = e.features[0].geometry.coordinates.slice();
    const properties = e.features[0].properties;

    let popupContent = '<div class="popup-content">';
    config.popup.fields.forEach(field => {
      if (properties[field]) {
        const label = config.popup.fieldLabels?.[field] || this.formatFieldName(field);
        popupContent += `<div><strong>${label}:</strong> ${properties[field]}</div>`;
      }
    });
    popupContent += '</div>';

    const popup = new mapboxgl.Popup()
      .setLngLat(coordinates)
      .setHTML(popupContent)
      .addTo(window.map);

    this.activePopups.push(popup);
  },

  /**
   * Retourne la liste des layers actifs
   */
  getActiveLayers() {
    return Array.from(this.state[this.currentTool].activeLayers);
  },

  /**
   * Supprime tous les layers
   */
  clearAllLayers() {
    const layers = Array.from(this.state[this.currentTool].activeLayers);
    layers.forEach(layerId => this.removeLayer(layerId));
    
    // Nettoyer aussi les IRIS
    this.state[this.currentTool].irisData = null;
    this.hideAllIrisLayers();
    
    this.closeAllPopups();
  },

  /**
   * Ferme tous les popups
   */
  closeAllPopups() {
    this.activePopups.forEach(popup => popup.remove());
    this.activePopups = [];
  },

  /**
   * Notifie Bubble des changements
   */
  notifyBubble(event, data) {
    if (typeof bubble_fn_layerEvent === 'function') {
      bubble_fn_layerEvent({ event, ...data });
    }
  },

  /**
   * Formate les noms de champs pour l'affichage
   */
  formatFieldName(field) {
    const mapping = {
      'nom': 'Nom',
      'adresse': 'Adresse',
      'prix': 'Prix',
      'surface': 'Surface'
    };
    return mapping[field] || field;
  }
};

// ===== API POUR BUBBLE (INCHANG√âE) =====

window.addMapLayer = function(layerId) {
  if (!window.layerManager) {
    console.error('LayerManager not initialized');
    return false;
  }
  return window.layerManager.addLayer(layerId);
};

window.removeMapLayer = function(layerId) {
  if (!window.layerManager) {
    console.error('LayerManager not initialized');
    return false;
  }
  return window.layerManager.removeLayer(layerId);
};

window.switchMapTool = function(tool) {
  if (!window.layerManager) {
    console.error('LayerManager not initialized');
    return false;
  }
  return window.layerManager.switchTool(tool);
};

window.getActiveMapLayers = function() {
  if (!window.layerManager) {
    console.error('LayerManager not initialized');
    return [];
  }
  return window.layerManager.getActiveLayers();
};

window.clearAllMapLayers = function() {
  if (!window.layerManager) {
    console.error('LayerManager not initialized');
    return false;
  }
  return window.layerManager.clearAllLayers();
};

// ===== FONCTIONS SP√âCIALES POUR LA ZONE DE RECHERCHE =====

/**
 * Marque qu'une zone de recherche est active pour l'outil actuel
 * √Ä appeler depuis Bubble apr√®s d√©finition de zone
 */
window.markSearchAreaActive = function() {
  if (!window.layerManager) return;
  window.layerManager.state[window.layerManager.currentTool].hasSearchArea = true;
  console.log(`üîç Zone de recherche marqu√©e active pour ${window.layerManager.currentTool}`);
};

/**
 * Marque qu'un marqueur d'adresse est actif (Explorer uniquement)
 * √Ä appeler depuis Bubble apr√®s cr√©ation du marqueur
 */
window.markAddressMarkerActive = function(lon, lat) {
  if (!window.layerManager || window.layerManager.currentTool !== 'explorer') return;
  window.layerManager.state.explorer.addressMarker = { lon, lat };
  console.log(`üìç Marqueur adresse Explorer sauvegard√©:`, { lon, lat });
};

/**
 * Marque qu'un marqueur radius est actif (Trouver uniquement)  
 * √Ä appeler depuis Bubble apr√®s cr√©ation du marqueur
 */
window.markRadiusMarkerActive = function(lon, lat) {
  if (!window.layerManager || window.layerManager.currentTool !== 'trouver') return;
  window.layerManager.state.trouver.radiusMarker = { lon, lat };
  console.log(`üìç Marqueur radius Trouver sauvegard√©:`, { lon, lat });
};

/**
 * R√©initialise la recherche - REMPLACE window.resetRecherche()
 */
window.resetSearchArea = function() {
  console.log("üîÑ R√©initialisation zone de recherche");
  
  if (!window.layerManager) {
    console.error('LayerManager not initialized');
    return;
  }

  // Attendre que la carte soit pr√™te
  if (!window.map || !window.map.isStyleLoaded()) {
    setTimeout(window.resetSearchArea, 200);
    return;
  }

  // 1. Masquer SEULEMENT les IRIS (pas la zone de recherche)
  window.layerManager.hideAllIrisLayers();
  
  // 2. R√©initialiser les donn√©es IRIS de l'outil actuel
  window.layerManager.state[window.layerManager.currentTool].irisData = null;
  
  // 3. S'assurer que la zone de recherche reste visible
  // Restaurer collectivit√©s si donn√©es disponibles
  if (window.collectivitesData?.features?.length > 0) {
    ['collectivites-fill', 'collectivites-outline'].forEach(layerId => {
      if (window.map.getLayer(layerId)) {
        window.map.setLayoutProperty(layerId, 'visibility', 'visible');
        console.log(`‚úÖ Zone collectivit√©s maintenue visible: ${layerId}`);
      }
    });
  }
  
  // Restaurer rayon si donn√©es disponibles  
  if (window.radiusData?.features?.length > 0) {
    ['radius-fill', 'radius-outline'].forEach(layerId => {
      if (window.map.getLayer(layerId)) {
        window.map.setLayoutProperty(layerId, 'visibility', 'visible');
        console.log(`‚úÖ Zone rayon maintenue visible: ${layerId}`);
      }
    });
  }
  
  console.log("‚úÖ IRIS masqu√©s, zone de recherche pr√©serv√©e");
};

window.showToolIris = function(codes) {
  if (!window.layerManager) {
    console.error('LayerManager not initialized');
    return false;
  }
  return window.layerManager.showIrisForTool(codes);
};

///// FIN DU LAYER MANAGER ////////

///// ZONE DE RECHERCHE //////
/* ---------- fonctions globales appel√©es par Bubble ---------- */
let   globalBounds = null;     /* ‚Üê plus d‚Äôappel direct √† mapboxgl ici */
const collectiviteCodes = new Set();   // Pour suivre ce qui est affich√©

/* Affiche les polygones des collectivit√©s choisies */
window.showCollectivitePolygons = function(fc) {
  if (!window.map) {
    console.warn("üõë Map not initialized for showCollectivitePolygons");
    return;
  }

  // Sauvegarder les donn√©es
  window.collectivitesData = fc;
  console.log("‚úÖ Saved collectivites data:", fc.features.length, "features");

  // Ajouter ou mettre √† jour la source
  if (window.map.getSource('collectivites')) {
    window.map.getSource('collectivites').setData(fc);
  } else {
    window.map.addSource('collectivites', { type: 'geojson', data: fc });
    window.map.addLayer({
      id: 'collectivites-fill',
      type: 'fill',
      source: 'collectivites',
      paint: { 'fill-color': '#8A2BE2', 'fill-opacity': 0.25 }
    });
    window.map.addLayer({
      id: 'collectivites-outline',
      type: 'line',
      source: 'collectivites',
      paint: { 'line-color': '#8A2BE2', 'line-width': 2 }
    });
  }

  // M√©moriser les codes
  fc.features.forEach(f => collectiviteCodes.add(f.properties.code_insee));
  console.log("‚úÖ Updated collectiviteCodes:", Array.from(collectiviteCodes));

  // Calculer fitBounds
  const bbox = turf.bbox(fc);
  window.map.fitBounds(bbox, { padding: 60, duration: 600 });

  /* NEW ‚Äî on garde l‚Äôemprise ‚Äúcollectivit√©s‚Äù en m√©moire pour les resizing de la carte*/
window.lastCollectivitesBBox   = bbox;
window.lastCollectivitesPad    = 60;    // m√™me padding, pratique si tu le changes
};

window.removeCollectivite = function(code){
  if (!collectiviteCodes.has(code)) return;
  collectiviteCodes.delete(code);

  // Filtrer les features restantes
  const remaining = { type:'FeatureCollection',
                      features: Array.from(collectiviteCodes).map(c => {
                        return window.map.getSource('collectivites')
                                         ._data.features
                                         .find(f => f.properties.code_insee === c);
                      }).filter(Boolean) };

  // Mettre √† jour la source
  window.map.getSource('collectivites').setData(remaining);

  // Refit si encore des polygones
  if (remaining.features.length){
    const bbox = turf.bbox(remaining);
    window.map.fitBounds(bbox,{ padding:60, duration:600 });
  }
};

window.removeAllCollectivites = function(){
  collectiviteCodes.clear();
  if (window.map && window.map.getSource('collectivites')){
    window.map.removeLayer('collectivites-fill');
    window.map.removeLayer('collectivites-outline');
    window.map.removeSource('collectivites');
  }
};

///// FIN DE LA PARTIE ZONE DE RECHERCHE /////

    function initializeMap() {
      console.log('Tentative d‚Äôinitialisation de la carte');
      if (window.map) {
        console.log('Carte d√©j√† initialis√©e');
        return;
      }
      if (!document.getElementById('map') || typeof mapboxgl === 'undefined') {
        console.log('Mapbox GL JS ou #map non pr√™t, r√©essai dans 300ms');
        setTimeout(initializeMap, 300);
        return;
      }

      console.log('Initialisation de la carte...');
      mapboxgl.accessToken = 'pk.eyJ1IjoiaGFkcmllbmxlZ2VyIiwiYSI6ImNtYXBjbDlzYTBncGoyaXNhN3dpajI3b3MifQ.TatwRPDuazMQH2DfSkxv2w';
      try {
        window.map = new mapboxgl.Map({
          container: 'map',
          style: 'mapbox://styles/mapbox/streets-v12',
          center: [2.361, 48.852],
          zoom: 10
        });

/*************************************************************
 *  Petit utilitaire global : ex√©cute un callback quand la
 *  carte Mapbox est compl√®tement charg√©e
 *************************************************************/
window.runWhenMapReady = function (cb) {
  // 1) carte d√©j√† pr√™te ‚Üí on ex√©cute tout de suite
  if (window.map && window.map.loaded()) {
    try { cb(); } catch (err) { console.error(err); }
    return;
  }
  // 2) sinon on r√©-essaie toutes les 200 ms
  setTimeout(function () { window.runWhenMapReady(cb); }, 200);
};



/* ‚ñ∏‚ñ∏  AJOUTE ICI  ‚Äì observer automatique du redimensionnement  ‚ñ∏‚ñ∏ */
(function () {
  if (!window.ResizeObserver) return;           // vieux navigateurs

  const mapDiv = document.getElementById('map');
  if (!mapDiv) return;

  const ro = new ResizeObserver(() => {
    if (!window.map) return;

    // 1) pr√©venir Mapbox que le <canvas> a chang√© de taille
    window.map.resize();

    // 2) recadrer sur la derni√®re emprise ‚Äúcollectivit√©s‚Äù, si on l‚Äôa m√©moris√©e
    if (window.lastCollectivitesBBox) {
      window.map.fitBounds(window.lastCollectivitesBBox, {
        padding  : window.lastCollectivitesPad ?? 60,
        duration : 0          // 0 ms ‚Üí pas d‚Äôanimation perceptible
      });
    }
  });

  ro.observe(mapDiv);                 // lancement de l‚Äôobservation
  window._mapResizeObserver = ro;     // (facultatif) r√©f√©rence globale
})();
/* ‚ñ∏‚ñ∏  FIN du bloc ResizeObserver  ‚ñ∏‚ñ∏ */

        window.map.on('load', () => {
          console.log('Carte charg√©e avec succ√®s');
          Object.keys(layerConfigs).forEach(layerId => {
            if (!window.map.getSource(layerId)) {
              window.map.addSource(layerId, layerConfigs[layerId].source);
            }
          });

        // Ajout de Claude pour g√©rer les layers
        window.layerManager.init();
        });

        window.map.on('error', (e) => console.error('Erreur Mapbox :', e));
      } catch (error) {
        console.error('Erreur lors de l‚Äôinitialisation :', error);
      }
    }

// PARAMETRAGE DES SEARCHBOX EXTERNALISEES

// Param√©trage du rayon (Trouver / Second mode de recherche)
/* -------- variables globales pour ce mode -------- */
window.radiusCenter = null;   // {lon,lat}
window.radiusKm     = 5;      // distance en km

/* Cr√©e le cercle ou le met √† jour */
function drawRadius() {
  console.log("‚û°Ô∏è drawRadius called with:", { center: window.radiusCenter, radiusKm: window.radiusKm });

  if (!window.map || !window.map.loaded()) {
    console.warn("üõë Cannot draw radius: map not loaded");
    return;
  }

  if (!window.radiusCenter || typeof window.radiusCenter.lon !== 'number' || typeof window.radiusCenter.lat !== 'number') {
    console.warn("üõë Cannot draw radius: invalid or missing radiusCenter");
    return;
  }

  if (typeof window.radiusKm !== 'number' || window.radiusKm <= 0) {
    console.warn("üõë Cannot draw radius: invalid or missing radiusKm, using default 5km");
    window.radiusKm = 5; // Valeur par d√©faut
  }

  // G√©n√©rer le GeoJSON du cercle
  let geojson;
  try {
    const circleFeature = turf.circle([window.radiusCenter.lon, window.radiusCenter.lat], window.radiusKm, { steps: 64, units: 'kilometers' });
    geojson = {
      type: 'FeatureCollection',
      features: [circleFeature]
    };
  } catch (error) {
    console.error("üõë Error generating circle GeoJSON:", error);
    geojson = { type: 'FeatureCollection', features: [] };
  }

  // Sauvegarder dans window.radiusData
  window.radiusData = geojson;
  console.log("‚úÖ Saved radius data:", geojson.features.length, "features");

  // Mettre √† jour ou cr√©er la source et les couches
  if (window.map.getSource('radius')) {
    window.map.getSource('radius').setData(geojson);
    console.log("üîç Updated radius source");
  } else {
    try {
      window.map.addSource('radius', { type: 'geojson', data: geojson });
      window.map.addLayer({
        id: 'radius-fill',
        type: 'fill',
        source: 'radius',
        paint: { 'fill-color': '#8A2BE2', 'fill-opacity': 0.2 }
      });
      window.map.addLayer({
        id: 'radius-outline',
        type: 'line',
        source: 'radius',
        paint: { 'line-color': '#8A2BE2', 'line-width': 2 }
      });
      console.log("‚ûï Added radius source and layers");
    } catch (error) {
      console.error("üõë Error adding radius source or layers:", error);
    }
  }
}

/* Expos√© √† Bubble : change la distance (km) */
window.updateRadius = function(km) {
  console.log("‚û°Ô∏è updateRadius called with:", km);
  if (typeof km !== 'number' || isNaN(km) || km <= 0) {
    console.warn("üõë Invalid radius value, using default 5km");
    window.radiusKm = 5;
  } else {
    window.radiusKm = km;
  }
  drawRadius();
};

/* Expos√© √† Bubble : efface tout (si onglet switch) */
window.clearRadius = function() {
  console.log("‚û°Ô∏è clearRadius called");

  // 1. Supprimer le cercle s‚Äôil existe
  if (window.map && window.map.getSource('radius')) {
    if (window.map.getLayer('radius-fill')) {
      window.map.removeLayer('radius-fill');
      console.log("‚úÖ Removed radius-fill layer");
    }
    if (window.map.getLayer('radius-outline')) {
      window.map.removeLayer('radius-outline');
      console.log("‚úÖ Removed radius-outline layer");
    }
    window.map.removeSource('radius');
    console.log("‚úÖ Removed radius source");
  }

  // 2. Supprimer le marqueur centre s‚Äôil existe
  if (window.radiusMarker) {
    window.radiusMarker.remove();
    window.radiusMarker = null;
    console.log("‚úÖ Removed radius marker");
  }

  // 3. R√©initialiser les variables
  window.radiusCenter = null;
  window.radiusKm = null;
  window.radiusData = { type: 'FeatureCollection', features: [] };
  console.log("‚úÖ Reset radius variables and data");
};


/* -------------------------------------------------- */
/*  A)  SearchBox ¬´ Trouver ¬ª (SB)   */
/* -------------------------------------------------- */
function initExternalSearch_Trouver() {
  if (!document.getElementById('radius-search') || !window.map) {
    console.log("Waiting for radius-search or map to be ready...");
    setTimeout(initExternalSearch_Trouver, 300);
    return;
  }

  const sb = new mapboxsearch.MapboxSearchBox();
  sb.accessToken = mapboxgl.accessToken;
  sb.options = { types: 'address,poi', language: 'fr', placeholder: 'Tapez une adresse ou le nom d\'un lieu' };
  sb.mapboxgl = mapboxgl;
  sb.marker = false;
  sb.bindMap(window.map);

  const host = document.getElementById('radius-search');  // le placeholder Bubble
  host.innerHTML = '';            // au cas o√π
  host.appendChild(sb);           // <-- c‚Äôest cette ligne qui manquait
  sb.style.width = '100%';        // pleine largeur

  sb.addEventListener('retrieve', e => {
    const [lon, lat] = e.detail.features[0].geometry.coordinates;

    // 1. Stocker le centre
    window.radiusCenter = { lon, lat };
    // D√©finir un rayon par d√©faut si non d√©fini
    if (typeof window.radiusKm !== 'number' || window.radiusKm <= 0) {
      window.radiusKm = 5; // Rayon par d√©faut
      console.log("‚úÖ Set default radiusKm to 5");
    }

    // 2. Placer (ou d√©placer) le marqueur central
    if (!window.radiusMarker) {
      window.radiusMarker = new mapboxgl.Marker({ color: '#8A2BE2' })
        .setLngLat([lon, lat])
        .addTo(window.map);
    } else {
      window.radiusMarker.setLngLat([lon, lat]);
    }

    // NOUVEAU - Sauvegarder le marqueur dans le layerManager
    markRadiusMarkerActive(lon, lat);

    // 3. Dessiner / mettre √† jour le cercle
    drawRadius();

    // 4. Informer Bubble
    if (typeof bubble_fn_pointSBtrouver === 'function') {
      bubble_fn_pointSBtrouver({ output1: lon, output2: lat });
    }
  });

  sb.addEventListener('clear', () => {
    // 1. Retirer le marqueur centre s‚Äôil existe
    if (window.radiusMarker) {
      window.radiusMarker.remove();
      window.radiusMarker = null;
    }
    // 2. Effacer le cercle et r√©initialiser les variables
    window.clearRadius();
  });
}

initExternalSearch_Trouver();   // lance l‚Äôattente

/* -------------------------------------------------- */
/*  FIN A)  SearchBox ¬´ Trouver ¬ª                     */
/* -------------------------------------------------- */

/* ----------------------------------------------------- */
/*  B)  SearchBox ¬´ Explorer ¬ª (SB) ‚Äì centr√©e et focus   */
/* ----------------------------------------------------- */

function initExternalSearch_Explorer () {
  const anchor = document.getElementById('mapbox-searchbox');          // le faux HTML
  const host   = document.getElementById('global-searchbox-container'); // le groupe Bubble

  if (!anchor || !host || !window.map) {
    setTimeout(initExternalSearch_Explorer, 300);
    return;
  }

  /* 1. Cr√©e la SearchBox Mapbox */
  const sb = new mapboxsearch.MapboxSearchBox();
  sb.accessToken = mapboxgl.accessToken;
  sb.options = {
    types       : 'address,poi',
    language    : 'fr',
    placeholder : 'Tapez une adresse ou un lieu'
  };
  sb.mapboxgl = mapboxgl;
  sb.marker   = false;
  sb.bindMap(window.map);

  /* 2. Vide le conteneur puis ins√®re la SearchBox */
  host.innerHTML = '';          // ‚ö†Ô∏è on enl√®ve le placeholder qui bloquait les clics
  host.appendChild(sb);

  /* 3. Style du conteneur : reste dans le flux, centre le contenu */
  Object.assign(host.style, {
    position       : 'relative',   // le groupe reste ‚Äúnormal‚Äù
    display        : 'flex',
    alignItems     : 'center',     // centre verticalement
    justifyContent : 'center',     // centre horizontalement
    pointerEvents  : 'auto',       // re√ßoit bien les clics
    zIndex         : 3000          // au-dessus des autres groupes Bubble
  });

  /* 4. Style de la SearchBox elle-m√™me */
  sb.style.width = '100%';        // occupe toute la largeur du groupe
  sb.style.minWidth = '280px';    // limite max si tu veux
  sb.style.maxWidth = '600px';    // limite max si tu veux

  /* 5. Le dropdown doit rester devant tout */
  const style = document.createElement('style');
  style.textContent = `
    .mapbox-searchbox__suggestions { z-index: 99999 !important; }
    .mapbox-searchbox              { z-index: 99998 !important; }
  `;
  document.head.appendChild(style);

  /* 6. Callbacks vers Bubble */
sb.addEventListener('retrieve', e => {
  const [lon, lat] = e.detail.features[0].geometry.coordinates;

  /* A) centrer / zoomer */
  window.map.flyTo({ center: [lon, lat], zoom: 15 });

  /* B) placer ou d√©placer le marqueur  üÜï */
  if (!window.addressMarker) {
    window.addressMarker = new mapboxgl.Marker({ color: '#ff0066' })  // rose fuchsia ?
                              .setLngLat([lon, lat])
                              .addTo(window.map);
  } else {
    window.addressMarker.setLngLat([lon, lat]);
  }

    /* NOUVEAU - Sauvegarder le marqueur dans le layerManager */
  markAddressMarkerActive(lon, lat);

  /* C) pr√©venir Bubble (inchang√©) */
    if (typeof bubble_fn_pointSBexplorer === 'function') {
      bubble_fn_pointSBexplorer({ output1: lon, output2: lat });
    }
});

  /* D) Suppression du marqueur */
  sb.addEventListener('clear', () => {
    if (window.addressMarker) {
      window.addressMarker.remove();
      window.addressMarker = null;
    }
});


  console.log('‚úÖ SearchBox externe initialis√©e ‚Äì centr√©e et 100 % cliquable');
}

initExternalSearch_Explorer();  // lance l‚Äôattente

/* -------------------------------------------------- */
/*  FIN B)  SearchBox ¬´ Explorer ¬ª ‚Äì centr√©e et focus     */
/* -------------------------------------------------- */

/* =========  UTILITAIRE : s‚Äôassure que les deux couches de s√©lection existent ========== */
function ensureIrisSelectedLayers() {
  if (!window.map || !window.map.getSource('iris')) return;

  /* Remplissage jaune translucide */
  if (!window.map.getLayer('iris-selected-fill')) {
    window.map.addLayer({
  id: 'iris-selected-fill',
  type: 'fill',
  source: 'iris',
  'source-layer': layerConfigs.iris.sourceLayer,
  paint: {
    'fill-color': 'rgba(255,215,0,0.35)',
    'fill-opacity': 0.8
  },
  filter: ['==', ['get', 'CODE_IRIS'], '']
}, 'settlement-subdivision-label');   // ‚Üê ancre toujours pr√©sente
  }

  /* Bordure or √©paisse */
  if (!window.map.getLayer('iris-selected-outline')) {
window.map.addLayer({
  id: 'iris-selected-outline',
  type: 'line',
  source: 'iris',
  'source-layer': layerConfigs.iris.sourceLayer,
  paint: { 'line-color': '#FFD700', 'line-width': 3 },
  filter: ['==', ['get', 'CODE_IRIS'], '']
}, 'settlement-subdivision-label');   // m√™me ancre robuste
}
}

/* =========  Permet la s√©lection des IRIS sur la carte au clic sur l'IRIS dans la liste c√¥t√© Bubble ========== */
window.focusIrisFromBubble = function(codeIris){
  if (!codeIris) return;

  if (!window.map || !window.map.loaded()){
    setTimeout(() => window.focusIrisFromBubble(codeIris), 300);
    return;
  }

  /* 1‚Ää‚Äî‚ÄäSurligner imm√©diatement */
  window.selectGeometry('iris', codeIris);

  /* 2‚Ää‚Äî‚ÄäRecentre, sans toucher au zoom */
  const feat = window.map.querySourceFeatures('iris', {
    sourceLayer: layerConfigs.iris.sourceLayer,
    filter: ['==', ['get', 'CODE_IRIS'], codeIris]
  })[0];

  if (feat) {
    const center = turf.center(feat).geometry.coordinates;  // [lon,lat]
    window.map.easeTo({
      center,
      duration: 600,
      zoom: window.map.getZoom()      // ‚Üê niveau actuel, donc pas de changement
    });
  }
};



/* =========  UTILITAIRE : capter les clics sur iris-fill et iris-temp  ========== */
function registerIrisClickListeners() {
  ['iris-fill', 'iris-temp'].forEach(layerId => {
    // Retirer les anciens listeners pour √©viter les doublons
    window.map.off('click', layerId);
    window.map.off('mouseenter', layerId);
    window.map.off('mouseleave', layerId);
    
    if (window.map.getLayer(layerId)) {
      window.map.on('click', layerId, e => {
        const codeIris = e.features[0].properties['CODE_IRIS'];
        console.log('IRIS cliqu√©:', codeIris);
        window.selectGeometry('iris', codeIris);
      });
      
      window.map.on('mouseenter', layerId, () => {
        window.map.getCanvas().style.cursor = 'pointer';
      });
      
      window.map.on('mouseleave', layerId, () => {
        window.map.getCanvas().style.cursor = '';
      });
      
      console.log(`‚úÖ Listeners ajout√©s pour ${layerId}`);
    }
  });
}

   /****************************************************
     * FONCTION hideAllLayers
     * On masque fill, outline et labels
     ****************************************************/
    function hideAllLayers() {  // ****CHANGEMENT****
      if (!window.map) return;
      console.log('=== hideAllLayers called ===');
      Object.keys(layerConfigs).forEach(layerId => {
        // Fill
        if (window.map.getLayer(layerId + '-fill')) {
          window.map.setLayoutProperty(layerId + '-fill', 'visibility', 'none');
        }
        // Outline
        if (window.map.getLayer(layerId + '-outline')) {
          window.map.setLayoutProperty(layerId + '-outline', 'visibility', 'none');
        }
        // Labels
        if (window.map.getLayer(layerId + '-labels')) {
          window.map.setLayoutProperty(layerId + '-labels', 'visibility', 'none');
        }
      });
    }
    window.hideAllLayers = hideAllLayers;

function addLayer(layerId) {
  const config = layerConfigs[layerId];
  if (!config || !window.map) return;

  console.log(`Ajout ou mise √† jour de ${layerId} (fill + outline)`);

  // V√©rifier si la source existe, sinon l‚Äôajouter
  if (!window.map.getSource(layerId)) {
    console.log(`Source ${layerId} absente, ajout...`);
    try {
      window.map.addSource(layerId, config.source);
      console.log(`Source ${layerId} ajout√©e`);
    } catch (error) {
      console.error(`Erreur lors de l‚Äôajout de la source ${layerId}:`, error);
      return;
    }
  }

let fillPaintObj;
  if (config.isChoropleth) {
    // Expression pour g√©rer les valeurs nulles dans la couleur
    const colorExpr = [
      'case',
      ['==', ['get', config.property], null], config.nullColor || '#d3d3d3', // Couleur pour null
      ['step', ['get', config.property], config.colors[0], ...config.breaks.flatMap((brk, i) => [brk, config.colors[i + 1]])]
    ];
    fillPaintObj = {
      'fill-color': colorExpr,
      'fill-opacity': config.opacity ?? 0.7
    };
    console.log(`Expression choropl√®the pour ${layerId}:`, colorExpr);
  } else {
    fillPaintObj = config.basePaint ? { ...config.basePaint } : {
      'fill-color': '#2C3E50',
      'fill-opacity': 0.8
    };
    if (config.useFeatureStateClicked) {
      fillPaintObj['fill-color'] = [
        'case',
        ['boolean', ['feature-state', 'clicked'], false],
        '#d0a4f7',
        fillPaintObj['fill-color']
      ];
    }
  }


// Gestion sp√©ciale pour le layer iris_meilleure_ecole
if (layerId === 'iris_meilleure_ecole') {
  const radius = window.currentEcoleRadius || '300';
  const secteur = window.currentEcoleSecteur || 'Public et priv√©';
  
  // Mettre √† jour la propri√©t√© en fonction du rayon
  config.property = `ecole_${radius}_ips`;
  if (config.labels) {
    config.labels.field = `ecole_${radius}_ips`;
  }
  
  // Appliquer le filtre apr√®s la cr√©ation des couches
  window.map.once('idle', () => {
    if (secteur !== 'Public et priv√©') {
      const secteurField = `ecole_${radius}_secteur`;
      
      // Cr√©er le filtre
      const filter = ['==', ['get', secteurField], secteur];
      
      // Appliquer sur toutes les couches
      if (window.map.getLayer(fillLayerId)) {
        window.map.setFilter(fillLayerId, filter);
      }
      if (window.map.getLayer(outlineLayerId)) {
        window.map.setFilter(outlineLayerId, filter);
      }
      if (config.labels?.enabled && window.map.getLayer(labelLayerId)) {
        window.map.setFilter(labelLayerId, filter);
      }
    }
  });
}

  

  const fillLayerId = layerId + '-fill';
  if (window.map.getLayer(fillLayerId)) {
    console.log(`Couche ${fillLayerId} d√©j√† pr√©sente, mise √† jour du style`);
    window.map.setPaintProperty(fillLayerId, 'fill-color', fillPaintObj['fill-color']);
    window.map.setPaintProperty(fillLayerId, 'fill-opacity', fillPaintObj['fill-opacity']);
  } else {
    console.log(`Couche ${fillLayerId} absente, ajout en cours...`);
    try {
      window.map.addLayer({
        id: fillLayerId,
        type: 'fill',
        source: layerId,
        'source-layer': config.sourceLayer,
        minzoom: config.minzoom,
        maxzoom: config.maxzoom,
        paint: fillPaintObj
      }, 'settlement-subdivision-label');
      console.log(`Couche ${fillLayerId} ajout√©e`);
    } catch (error) {
      console.error(`Erreur lors de l‚Äôajout de ${fillLayerId}:`, error);
    }
  }

  const outlineLayerId = layerId + '-outline';
  if (window.map.getLayer(outlineLayerId)) {
    console.log(`Couche ${outlineLayerId} d√©j√† pr√©sente`);
    // Pas besoin de mise √† jour ici, les propri√©t√©s sont statiques
  } else {
    console.log(`Couche ${outlineLayerId} absente, ajout en cours...`);
    try {
      window.map.addLayer({
        id: outlineLayerId,
        type: 'line',
        source: layerId,
        'source-layer': config.sourceLayer,
        minzoom: config.minzoom,
        maxzoom: config.maxzoom,
        paint: {
          'line-color': '#FFFFFF',
          'line-width': 1,
          'line-opacity': 0.8,
          'line-blur': 0
        },
        layout: {
          'line-join': 'round',
          'line-cap': 'round'
        }
      }, 'settlement-subdivision-label');
      console.log(`Couche ${outlineLayerId} ajout√©e`);
    } catch (error) {
      console.error(`Erreur lors de l‚Äôajout de ${outlineLayerId}:`, error);
    }
  }



if (config.labels?.enabled) {
  const labelLayerId = `${layerId}-labels`;
  let textFieldExpr;

// G√©rer les valeurs nulles dans les labels avec "NA"
    const valueExpr = ['coalesce', ['get', config.labels.field], 'NA']; // Remplace null par "NA"

  // D√©terminer le format √† appliquer
switch (config.labels.labelFormat) {
      case 'percent-1': // Ex. "2,9 %"
        textFieldExpr = [
          'case',
          ['==', ['get', config.labels.field], null], 'NA',
          ['concat', ['number-format', ['*', ['to-number', valueExpr], 100], { 'min-fraction-digits': 1, 'max-fraction-digits': 1 }], ' %']
        ];
        break;
      case 'percent-0': // Ex. "3 %"
        textFieldExpr = [
          'case',
          ['==', ['get', config.labels.field], null], 'NA',
          ['concat', ['round', ['*', ['to-number', valueExpr], 100]], ' %']
        ];
        break;
      case 'currency-euro': // Ex. "45 098 ‚Ç¨"
        textFieldExpr = [
          'case',
          ['==', ['get', config.labels.field], null], 'NA',
          ['concat', ['number-format', ['to-number', valueExpr], { 'locale': 'fr', 'min-fraction-digits': 0, 'max-fraction-digits': 0 }], ' ‚Ç¨']
        ];
        break;
      case 'number-1': // Ex. "13,7"
        textFieldExpr = [
          'case',
          ['==', ['get', config.labels.field], null], 'NA',
          ['number-format', ['to-number', valueExpr], { 'min-fraction-digits': 1, 'max-fraction-digits': 1 }]
        ];
        break;
      default: // Valeur brute
        textFieldExpr = valueExpr;
    }

    if (window.map.getLayer(labelLayerId)) {
      console.log(`Couche ${labelLayerId} d√©j√† pr√©sente, mise √† jour du text-field`);
      window.map.setLayoutProperty(labelLayerId, 'text-field', textFieldExpr);
    } else {
      console.log(`Couche ${labelLayerId} absente, ajout en cours...`);
      try {
        window.map.addLayer({
          id: labelLayerId,
          type: 'symbol',
          source: layerId,
          'source-layer': config.sourceLayer,
          minzoom: config.labels.minzoom || 0,
          maxzoom: config.maxzoom || 22,
          layout: {
            'text-field': textFieldExpr,
            'text-size': config.labels.textSize || 12,
            'text-anchor': 'center'
          },
          paint: {
            'text-color': config.labels.color || '#000',
            'text-halo-color': config.labels.haloColor || '#fff',
            'text-halo-width': config.labels.haloWidth || 1
          }
        }, 'settlement-subdivision-label');
        console.log(`Couche ${labelLayerId} ajout√©e`);
      } catch (error) {
        console.error(`Erreur lors de l‚Äôajout de ${labelLayerId}:`, error);
      }
    }
  }

  if (config.clickable && !window.map.listens('click', fillLayerId)) {
    window.map.on('click', fillLayerId, e => handleLayerClick(e, layerId));
    window.map.on('mouseenter', fillLayerId, () => window.map.getCanvas().style.cursor = 'pointer');
    window.map.on('mouseleave', fillLayerId, () => window.map.getCanvas().style.cursor = '');
  }

// Modif de la fonction pour g√©rer les pop-ups des cartes choropleths
if (config.clickable && config.popup) {
  const fillLayerId = layerId + '-fill';
  
  // Cr√©er le popup
  const popup = new mapboxgl.Popup({
    closeButton: true,
    closeOnClick: true
  });

  // Sur le clic
  window.map.on('click', fillLayerId, (e) => {
    if (e.features.length === 0) return;
    
    const feature = e.features[0];
    const properties = feature.properties;
    
    // Construire le contenu du popup
    let popupContent = '<div class="popup-content">';
    
    // Pour les √©coles, affichage conditionnel selon le secteur
    if (layerId.startsWith('top_ecole_')) {
      const secteur = window.currentEcoleSecteur || 'Public et priv√©';
      
      // Toujours afficher le nom du quartier
      if (properties.nom_iris) {
        popupContent += `<div><strong>Quartier :</strong> ${properties.nom_iris}</div><hr>`;
      }
      
      // Afficher selon le secteur s√©lectionn√©
      if (secteur === 'Public' || secteur === 'Public et priv√©') {
        if (properties.nom_pu) {
          popupContent += `<div><strong>Meilleure √©cole publique √† 300m¬†:</strong> ${properties.nom_pu}</div>`;
          if (properties.ips_pu) popupContent += `<div><strong>IPS :</strong> ${properties.ips_pu}</div>`;
          if (properties.adresse_pu) popupContent += `<div><strong>Adresse :</strong> ${properties.adresse_pu}</div>`;
        }
      }
      
      if ((secteur === 'Priv√©' || secteur === 'Public et priv√©') && properties.nom_pr) {
        if (secteur === 'Public et priv√©' && properties.nom_pu) popupContent += '<hr>';
        popupContent += `<div><strong>Meilleure √©cole priv√©e √† 300m¬†:</strong> ${properties.nom_pr}</div>`;
        if (properties.ips_pr) popupContent += `<div><strong>IPS :</strong> ${properties.ips_pr}</div>`;
        if (properties.adresse_pr) popupContent += `<div><strong>Adresse :</strong> ${properties.adresse_pr}</div>`;
      }
    } else {
      // Pour les autres choropl√®thes, affichage standard
      config.popup.fields.forEach(field => {
        if (properties[field] !== null && properties[field] !== undefined) {
          const label = config.popup.fieldLabels?.[field] || field;

        let value = properties[field];
        
        // Formatage sp√©cial pour part_log_soc
        if (layerId === 'part_log_soc') {
          if (field === 'part_log_soc') {
            // Convertir en pourcentage sans d√©cimales
            value = Math.round(value * 100) + '%';
          } else if (['txlsplai', 'txlsplus', 'txlspls', 'txlspli'].includes(field)) {
            // Arrondir et ajouter %
            value = Math.round(value) + '%';
          } else if (field === 'nb_logsoc') {
            // Garder tel quel (nombre entier)
            value = Math.round(value);
          }
        }

          popupContent += `<div><strong>${label}:</strong> ${value}</div>`;
        }
      });
    }
    
    popupContent += '</div>';
    
    // Afficher le popup
    popup.setLngLat(e.lngLat)
      .setHTML(popupContent)
      .addTo(window.map);
  });

  // Changer le curseur au survol
  window.map.on('mouseenter', fillLayerId, () => {
    window.map.getCanvas().style.cursor = 'pointer';
  });
  
  window.map.on('mouseleave', fillLayerId, () => {
    window.map.getCanvas().style.cursor = '';
  });
}



}


    let lastClickedFeatureId = null;

    function handleLayerClick(e, layerId) {
      const config = layerConfigs[layerId];
      if (!config || !e.features[0]) return;

      const feature = e.features[0];
      const codeIris = feature.properties[config.idField];
      window.selectGeometry(layerId, codeIris);  // <--- On r√©utilise la fonction commune
    }

window.updateMapLayers = function(layerId) {
  if (!window.map) return;

  console.log(`Mise √† jour de ${layerId}`);

  addLayer(layerId);

  const config = layerConfigs[layerId];
  if (window.map.getLayer(layerId + '-fill')) {
    window.map.setLayoutProperty(layerId + '-fill', 'visibility', 'visible');
    console.log(`${layerId}-fill rendu visible`);
  } else {
    console.error(`${layerId}-fill n‚Äôa pas √©t√© ajout√©`);
  }
  if (window.map.getLayer(layerId + '-outline')) {
    window.map.setLayoutProperty(layerId + '-outline', 'visibility', 'visible');
    console.log(`${layerId}-outline rendu visible`);
  } else {
    console.error(`${layerId}-outline n‚Äôa pas √©t√© ajout√©`);
  }
  if (config?.labels?.enabled && window.map.getLayer(layerId + '-labels')) {
    window.map.setLayoutProperty(layerId + '-labels', 'visibility', labelsVisible ? 'visible' : 'none');
    console.log(`${layerId}-labels mis √† ${labelsVisible ? 'visible' : 'none'}`);
  } else if (config?.labels?.enabled) {
    console.error(`${layerId}-labels n‚Äôa pas √©t√© ajout√©`);
  }

  window.map.triggerRepaint();
  console.log(`Rendu forc√© pour ${layerId}`);
};

    // Gestion des couches choropleths
  /****************************************************
     * showChoroplethLayer(layerId)
     * => exclusif : on masque l'ancien + on affiche le nouveau
     ****************************************************/

let labelsVisible = true; // Par d√©faut, les labels sont visibles

window.showChoroplethLayer = function(layerId) {
  if (!window.map) {
    console.log(`Carte non initialis√©e pour ${layerId}, attente...`);
    setTimeout(() => window.showChoroplethLayer(layerId), 300);
    return;
  }

  const config = layerConfigs[layerId];
  if (!config || !config.isChoropleth) {
    console.warn(`${layerId} n‚Äôest pas un choropl√®the`);
    return;
  }

  console.log(`[showChoroplethLayer] On veut afficher : ${layerId}`);

  Object.keys(layerConfigs).forEach(other => {
    const c = layerConfigs[other];
    if (c.isChoropleth && other !== layerId) {
      if (window.map.getLayer(other + '-fill')) {
        window.map.setLayoutProperty(other + '-fill', 'visibility', 'none');
        console.log(`${other}-fill masqu√©`);
      }
      if (window.map.getLayer(other + '-outline')) {
        window.map.setLayoutProperty(other + '-outline', 'visibility', 'none');
        console.log(`${other}-outline masqu√©`);
      }
      if (c.labels?.enabled && window.map.getLayer(other + '-labels')) {
        window.map.setLayoutProperty(other + '-labels', 'visibility', 'none');
        console.log(`${other}-labels masqu√©`);
      }
    }
  });

  window.updateMapLayers(layerId);
  if (config.labels?.enabled && window.map.getLayer(layerId + '-labels')) {
    window.map.setLayoutProperty(layerId + '-labels', 'visibility', labelsVisible ? 'visible' : 'none');
    console.log(`${layerId}-labels mis √† ${labelsVisible ? 'visible' : 'none'}`);
  }

  currentChoropleth = layerId;
  window.map.triggerRepaint();
  console.log(`Affichage de ${layerId} termin√©`);
};

window.toggleLabels = function(show) {
  if (!window.map) {
    console.log("Carte non initialis√©e, r√©essai dans 300ms");
    setTimeout(() => window.toggleLabels(show), 300);
    return;
  }

  // V√©rifie si l‚Äô√©tat change vraiment pour √©viter les appels redondants
  if (labelsVisible === show) {
    console.log(`√âtat des labels d√©j√† √† ${show ? 'visible' : 'none'}, pas de changement`);
    return;
  }

  labelsVisible = show; // Mettre √† jour l‚Äô√©tat global
  console.log(`Toggle labels : ${show ? 'visible' : 'none'}`);
  const visibility = show ? 'visible' : 'none';

  Object.keys(layerConfigs).forEach(layerId => {
    const config = layerConfigs[layerId];
    if (config.labels?.enabled && window.map.getLayer(layerId + '-labels')) {
      window.map.setLayoutProperty(layerId + '-labels', 'visibility', visibility);
      console.log(`Labels de ${layerId} mis √† ${visibility}`);
    }
  });

  window.map.triggerRepaint();
};


    /****************************************************
     * hideChoropleth()
     * => masque le choropleth actif
     ****************************************************/
    window.hideChoropleth = function() { // ****CHANGEMENT****
      if (!currentChoropleth) return;
      const oldConfig = layerConfigs[currentChoropleth];
      // fill
      if (window.map.getLayer(currentChoropleth + '-fill')) {
        window.map.setLayoutProperty(currentChoropleth + '-fill', 'visibility', 'none');
      }
      // outline
      if (window.map.getLayer(currentChoropleth + '-outline')) {
        window.map.setLayoutProperty(currentChoropleth + '-outline', 'visibility', 'none');
      }
      // labels
      if (oldConfig?.labels?.enabled && window.map.getLayer(currentChoropleth + '-labels')) {
        window.map.setLayoutProperty(currentChoropleth + '-labels', 'visibility', 'none');
      }
      currentChoropleth = null;
    };

window.showLayerAfterResize = function(loadFunctionName, ...args) {
  if (!window.map) {
    console.log("Carte non initialis√©e, r√©essai dans 300ms");
    setTimeout(() => window.showLayerAfterResize(loadFunctionName, ...args), 300);
    return;
  }

  console.log(`D√©but de showLayerAfterResize pour ${loadFunctionName} avec args:`, args);

  window.map.resize();
  setTimeout(() => {
    if (!window.map.isStyleLoaded()) {
      console.log("Style non charg√©, attente...");
      window.map.once('render', () => {
        console.log("Carte rendue apr√®s resize");
        executeLoadFunction(loadFunctionName, args);
      });
    } else {
      console.log("Style d√©j√† charg√©, ex√©cution imm√©diate");
      executeLoadFunction(loadFunctionName, args);
    }
  }, 200);

  function executeLoadFunction(fnName, fnArgs) {
    if (typeof window[fnName] === 'function') {
      window[fnName](...fnArgs);
      window.map.triggerRepaint();
      console.log(`Ex√©cution de ${fnName} termin√©e, rendu forc√©`);
    } else {
      console.error(`La fonction ${fnName} n‚Äôexiste pas`);
    }
  }
};

    // Fonction pour param√©trer le toggle des labels des cartes
window.toggleLabels = function(show) {
  if (!window.map) {
    console.log("Carte non initialis√©e, r√©essai dans 300ms");
    setTimeout(() => window.toggleLabels(show), 300);
    return;
  }

  labelsVisible = show; // Mettre √† jour l‚Äô√©tat global
  console.log(`Toggle labels : ${show ? 'visible' : 'none'}`);
  const visibility = show ? 'visible' : 'none';

  Object.keys(layerConfigs).forEach(layerId => {
    const config = layerConfigs[layerId];
    if (config.labels?.enabled && window.map.getLayer(layerId + '-labels')) {
      window.map.setLayoutProperty(layerId + '-labels', 'visibility', visibility);
      console.log(`Labels de ${layerId} mis √† ${visibility}`);
    }
  });

  window.map.triggerRepaint();
};

window.resetRecherche = function() {
  console.log("‚û°Ô∏è resetRecherche called");

  /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Äì garde d‚Äôattente ‚Äì‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

  /* A) L‚Äôobjet map n‚Äôexiste pas encore ‚Üí on r√©-essaie dans 200 ms */
  if (!window.map) {
    setTimeout(window.resetRecherche, 200);
    return;
  }

  /* B) Le style Mapbox n‚Äôest pas encore compl√®tement rendu             */
  /*    ‚Üí on attend l‚Äô√©v√®nement ¬´ idle ¬ª (plus fiable que ¬´ load ¬ª)     */
  if (!window.map.isStyleLoaded()) {
    window.map.once('idle', () => window.resetRecherche());
    return;
  }

  /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Äì FIN de la garde ‚Äì‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

  // 1. Supprimer les couches temporaires IRIS
  ['iris-temp', 'iris-temp-outline'].forEach(layerId => {
    if (window.map.getLayer(layerId)) {
      window.map.removeLayer(layerId);
      console.log(`‚úÖ Removed ${layerId} layer`);
    }
  });

  // 2. Masquer et r√©initialiser les filtres des couches IRIS existantes
  ['iris-fill', 'iris-outline', 'iris-labels'].forEach(layerId => {
    if (window.map.getLayer(layerId)) {
      window.map.setLayoutProperty(layerId, 'visibility', 'none');
      window.map.setFilter(layerId, null);
      console.log(`‚úÖ Hid and reset filter for ${layerId}`);
      if (layerId === 'iris-outline') {
        window.map.setPaintProperty(layerId, 'line-width', 2);
        console.log("‚úÖ Reset iris-outline line-width to 2");
      }
    }
  });

  // 3. Restaurer les donn√©es en fonction de la m√©thode utilis√©e
  // Initialiser window.radiusData si n√©cessaire
  if (!window.radiusData || !window.radiusData.features) {
    window.radiusData = { type: 'FeatureCollection', features: [] };
    console.log("‚úÖ Initialized empty radiusData");
  }

  if (window.radiusData.features.length > 0 && window.radiusCenter && typeof window.radiusKm === 'number' && window.radiusKm > 0) {
    // M√©thode 2 : Restaurer le cercle
    console.log("üîÑ Restoring radius (method 2)");
    if (!window.map.getSource('radius')) {
      console.log("‚ûï Recreating radius source...");
      try {
        window.map.addSource('radius', {
          type: 'geojson',
          data: window.radiusData
        });
      } catch (error) {
        console.error("üî¥ Error recreating radius source:", error);
        return;
      }
    } else {
      console.log("üîç Updating radius source data...");
      window.map.getSource('radius').setData(window.radiusData);
    }

    if (!window.map.getLayer('radius-fill')) {
      console.log("‚ûï Adding radius-fill layer...");
      try {
        window.map.addLayer({
          id: 'radius-fill',
          type: 'fill',
          source: 'radius',
          paint: { 'fill-color': '#8A2BE2', 'fill-opacity': 0.2 }
        });
      } catch (error) {
        console.error("üî¥ Error adding radius-fill layer:", error);
      }
    } else {
      window.map.setLayoutProperty('radius-fill', 'visibility', 'visible');
      console.log("‚úÖ Made radius-fill visible");
    }

    if (!window.map.getLayer('radius-outline')) {
      console.log("‚ûï Adding radius-outline layer...");
      try {
        window.map.addLayer({
          id: 'radius-outline',
          type: 'line',
          source: 'radius',
          paint: { 'line-color': '#8A2BE2', 'line-width': 2 }
        });
      } catch (error) {
        console.error("üî¥ Error adding radius-outline layer:", error);
      }
    } else {
      window.map.setLayoutProperty('radius-outline', 'visibility', 'visible');
      console.log("‚úÖ Made radius-outline visible");
    }

    // Restaurer le marqueur
    if (!window.radiusMarker && window.radiusCenter) {
      console.log("‚ûï Recreating radius marker...");
      try {
        window.radiusMarker = new mapboxgl.Marker({ color: '#8A2BE2' })
          .setLngLat([window.radiusCenter.lon, window.radiusCenter.lat])
          .addTo(window.map);
      } catch (error) {
        console.error("üî¥ Error recreating radius marker:", error);
      }
    }

    console.log("‚úÖ Radius restored, keeping current map viewport");
  } else if (window.collectivitesData?.features?.length > 0) {
    // M√©thode 1 : Restaurer les collectivit√©s
    console.log("üîÑ Restoring collectivites (method 1)");
    if (!window.map.getSource('collectivites')) {
      console.log("‚ûï Recreating collectivites source...");
      try {
        window.map.addSource('collectivites', {
          type: 'geojson',
          data: window.collectivitesData
        });
      } catch (error) {
        console.error("üî¥ Error recreating collectivites source:", error);
        return;
      }
    } else {
      console.log("üîç Updating collectivites source data...");
      window.map.getSource('collectivites').setData(window.collectivitesData);
    }

    if (!window.map.getLayer('collectivites-fill')) {
      console.log("‚ûï Adding collectivites-fill layer...");
      try {
        window.map.addLayer({
          id: 'collectivites-fill',
          type: 'fill',
          source: 'collectivites',
          paint: { 'fill-color': '#8A2BE2', 'fill-opacity': 0.25 }
        });
      } catch (error) {
        console.error("üî¥ Error adding collectivites-fill layer:", error);
      }
    } else {
      window.map.setLayoutProperty('collectivites-fill', 'visibility', 'visible');
      console.log("‚úÖ Made collectivites-fill visible");
    }

    if (!window.map.getLayer('collectivites-outline')) {
      console.log("‚ûï Adding collectivites-outline layer...");
      try {
        window.map.addLayer({
          id: 'collectivites-outline',
          type: 'line',
          source: 'collectivites',
          paint: { 'line-color': '#8A2BE2', 'line-width': 2 }
        });
      } catch (error) {
        console.error("üî¥ Error adding collectivites-outline layer:", error);
      }
    } else {
      window.map.setLayoutProperty('collectivites-outline', 'visibility', 'visible');
      console.log("‚úÖ Made collectivites-outline visible");
    }

    console.log("‚úÖ Collectivit√©s restored, keeping current map viewport");
  } else {
    console.warn("‚ö†Ô∏è No data available to restore (neither collectivites nor radius)");
  }
};

  // 1) R√©initialiser l‚Äô√©ventuel feature cliqu√©
    // 2) Appliquer setFeatureState
    // 3) Appeler la fonction Bubble
window.selectGeometry = function(layerId, codeIris) {
  const config = layerConfigs[layerId];
  if (!window.map || !config) return;

  /* 0Ô∏è‚É£  s‚Äôassurer que les deux couches de s√©lection existent */
  ensureIrisSelectedLayers();

  /* 1Ô∏è‚É£  d√©placer le halo sur l‚ÄôIRIS cliqu√© */
  ['iris-selected-fill', 'iris-selected-outline'].forEach(selId => {
    window.map.setFilter(selId, ['==', ['get', 'CODE_IRIS'], codeIris]);
    window.map.setLayoutProperty(selId, 'visibility', 'visible');
    window.map.moveLayer(selId);               // sans second arg. = tout en haut
  });

  /* 2Ô∏è‚É£  notifier Bubble (format objet que Bubble attend) */
  if (typeof bubble_fn_mapClicked === 'function') {
    bubble_fn_mapClicked({ output1: layerId, output2: codeIris });
  }
};

    // Fonction qui va permettre la s√©lection des IRIS
function applySelectionPaint(allCodes, focusCode){
  // 1.  couleur de fond pour TOUS les IRIS affich√©s
  const baseFilter = ['match', ['get', 'CODE_IRIS'], allCodes, true, false];
  window.map.setFilter('iris-fill'        , baseFilter);
  window.map.setFilter('iris-outline'     , baseFilter);
  if (window.map.getLayer('iris-temp')) {          // cas o√π on utilise la couche temporaire
    window.map.setFilter('iris-temp'      , baseFilter);
    window.map.setFilter('iris-temp-outline', baseFilter);
  }

  // 2.  ‚Äúfocus‚Äù √©ventuel ‚ûú feature-state { clicked:true }
  //     on commence par tout remettre √† false
  const feats = window.map.querySourceFeatures('iris', {
      sourceLayer: layerConfigs['iris'].sourceLayer,
      filter: baseFilter
  });
  feats.forEach(f =>
    window.map.setFeatureState(
      { source:'iris', sourceLayer:layerConfigs['iris'].sourceLayer, id:f.id },
      { clicked:false })
  );

  if (focusCode){
    const f = feats.find(ff => ff.properties.CODE_IRIS === focusCode);
    if (f){
      window.map.setFeatureState(
        { source:'iris', sourceLayer:layerConfigs['iris'].sourceLayer, id:f.id },
        { clicked:true });
    }
  }
}

/* ---------- Fonctions expos√©es √† Bubble pour g√©rer les layers ---------- */
window.addMapLayer = function(layerId) {
  if (!window.layerManager) {
    console.error('LayerManager not initialized');
    return;
  }
  return window.layerManager.addLayer(layerId);
};

window.removeMapLayer = function(layerId) {
  if (!window.layerManager) {
    console.error('LayerManager not initialized');
    return;
  }
  return window.layerManager.removeLayer(layerId);
};

window.switchMapTool = function(tool) {
  if (!window.layerManager) {
    console.error('LayerManager not initialized');
    return;
  }
  return window.layerManager.switchTool(tool);
};

window.getActiveMapLayers = function() {
  if (!window.layerManager) {
    console.error('LayerManager not initialized');
    return [];
  }
  return window.layerManager.getActiveLayers();
};

window.clearAllMapLayers = function() {
  if (!window.layerManager) {
    console.error('LayerManager not initialized');
    return;
  }
  return window.layerManager.clearAllLayers();
};

// Change les rayons des √©coles et le secteur sur les cartes choropleths
window.configureEcoles = function(radius, secteur) {
  const validRadius = ['300', '600', '1000', '2000', '5000'];
  const validSecteurs = ['Public', 'Priv√©', 'Public et priv√©'];
  
  if (!validRadius.includes(radius)) radius = '300';
  if (!validSecteurs.includes(secteur)) secteur = 'Public et priv√©';
  
  // Sauvegarder les param√®tres actuels
  window.currentEcoleRadius = radius;
  window.currentEcoleSecteur = secteur;
  
  // D√©terminer le layer √† utiliser
  const layerId = `top_ecole_${radius}m`;
  const config = window.layerConfigs[layerId];
  
  if (!config) {
    console.error(`Layer ${layerId} non trouv√©`);
    return;
  }
  
  // Configurer la propri√©t√© selon le secteur
  if (secteur === 'Public') {
    config.property = 'ips_pu';
  } else if (secteur === 'Priv√©') {
    config.property = 'ips_pr';
  } else {
    // Pour "Public et priv√©", utiliser le meilleur des deux
    // Vous pourriez cr√©er une propri√©t√© calcul√©e c√¥t√© SQL ou utiliser une expression Mapbox
    config.property = 'ips_pu'; // Ou une logique plus complexe
  }
  
  if (config.labels) {
    config.labels.field = config.property;
  }
  
  // Masquer tous les autres layers √©coles
  ['300', '600', '1000', '2000', '5000'].forEach(r => {
    const otherId = `top_ecole_${r}m`;
    if (otherId !== layerId && window.layerManager.state[window.layerManager.currentTool].activeLayers.has(otherId)) {
      window.removeMapLayer(otherId);
    }
  });
  
  // Afficher le bon layer
  window.addMapLayer(layerId);
};

// √Ä la fin du fichier carte-mapbox-core.html, avec les autres fonctions window.*

window.setPrixMedianScale = function(scale, zoneCode = null) {
  const config = window.layerConfigs.prix_median;
  
  // D√©terminer les breaks appropri√©s
  let breaks;
  if (scale === 'national') {
    breaks = config.breaksConfig.national;
  } else if (scale === 'regional' && zoneCode) {
    breaks = config.breaksConfig.regional[zoneCode] || config.breaksConfig.national;
  } else if (scale === 'departmental' && zoneCode) {
    breaks = config.breaksConfig.departmental[zoneCode] || config.breaksConfig.national;
  } else {
    breaks = config.breaksConfig.national; // Fallback
  }
  
  // Mettre √† jour la configuration
  config.breaks = breaks;
  config.scaleLevel = scale;
  
  // Reconstruire l'expression de couleur pour le layer
  if (window.map.getLayer('prix_median-fill')) {
    const colorExpr = [
      'case',
      ['==', ['get', 'prix_median'], null], config.nullColor,
      ['step', ['get', 'prix_median'], 
        config.colors[0], 
        ...breaks.flatMap((brk, i) => [brk, config.colors[i + 1]])
      ]
    ];
    
    window.map.setPaintProperty('prix_median-fill', 'fill-color', colorExpr);
  }
};

// Fonction pour filtrer les √©coles par IPS
window.filterEcolesByIPS = function(minIPS = null, maxIPS = null) {
  if (!window.map) return;
  
  const layerId = 'points_ecoles-points';
  
  // Si le layer n'existe pas, on arr√™te
  if (!window.map.getLayer(layerId)) {
    console.warn(`Layer ${layerId} not found`);
    return;
  }
  
  // Construire le filtre
  let filter = ['all'];
  
  if (minIPS !== null && minIPS !== undefined) {
    filter.push(['>=', ['to-number', ['get', 'ips'], 0], minIPS]);
  }
  
  if (maxIPS !== null && maxIPS !== undefined) {
    filter.push(['<=', ['to-number', ['get', 'ips'], 999], maxIPS]);
  }
  
  // Si aucun filtre, on affiche tout
  if (filter.length === 1) {
    filter = null;
  }
  
  // Appliquer le filtre
  window.map.setFilter(layerId, filter);
  
  console.log(`√âcoles filtr√©es: IPS entre ${minIPS || 'min'} et ${maxIPS || 'max'}`);
};

// Fonction pour filtrer les coll√®ges par note
window.filterCollegesByNote = function(minNote = null, maxNote = null) {
  if (!window.map) return;
  
  const layerId = 'points_colleges-points';
  
  // Si le layer n'existe pas, on arr√™te
  if (!window.map.getLayer(layerId)) {
    console.warn(`Layer ${layerId} not found`);
    return;
  }
  
  // Construire le filtre
  let filter = ['all'];
  
  if (minNote !== null && minNote !== undefined) {
    filter.push(['>=', ['to-number', ['get', 'note_college'], 0], minNote]);
  }
  
  if (maxNote !== null && maxNote !== undefined) {
    filter.push(['<=', ['to-number', ['get', 'note_college'], 20], maxNote]);
  }
  
  // Si aucun filtre, on affiche tout
  if (filter.length === 1) {
    filter = null;
  }
  
  // Appliquer le filtre
  window.map.setFilter(layerId, filter);
  
  console.log(`Coll√®ges filtr√©s: Note entre ${minNote || 'min'} et ${maxNote || 'max'}`);
};

// Fonction pour r√©initialiser les filtres √©coles
window.resetEcolesFilter = function() {
  window.filterEcolesByIPS(null, null);
};

// Fonction pour r√©initialiser les filtres coll√®ges
window.resetCollegesFilter = function() {
  window.filterCollegesByNote(null, null);
};

    // D√©marrer l‚Äôinitialisation
    setTimeout(initializeMap, 100);
  </script>
</body>
</html>